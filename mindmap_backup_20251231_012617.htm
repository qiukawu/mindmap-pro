<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindFlow Pro - 专业思维导图</title>
    <style>
/* ==================== 基础样式 ==================== */
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
    --primary-color: #4ECDC4;
    --primary-dark: #3BA99C;
    --secondary-color: #2C3E50;
    --accent-color: #FF6B6B;
    --success-color: #2ECC71;
    --warning-color: #F39C12;
    --danger-color: #E74C3C;
    --bg-color: #F8FAFE;
    --panel-bg: #FFFFFF;
    --canvas-bg: #FAFBFC;
    --text-primary: #2C3E50;
    --text-secondary: #7F8C8D;
    --text-light: #BDC3C7;
    --border-color: #E8ECF1;
    --border-radius: 8px;
    --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
    --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
    --shadow-lg: 0 8px 32px rgba(0,0,0,0.16);
    --toolbar-height: 56px;
    --sidebar-width: 260px;
    --transition-fast: 0.15s ease;
    --transition-normal: 0.25s ease;
}

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    font-size: 14px;
    color: var(--text-primary);
    background: var(--bg-color);
}

/* ==================== 工具栏 ==================== */
.toolbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: var(--toolbar-height);
    background: var(--panel-bg);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    padding: 0 16px;
    gap: 8px;
    z-index: 1000;
    box-shadow: var(--shadow-sm);
}

.toolbar-brand {
    display: flex;
    align-items: center;
    gap: 8px;
    padding-right: 16px;
    border-right: 1px solid var(--border-color);
    margin-right: 8px;
}

.toolbar-brand .logo { font-size: 24px; }

.toolbar-brand .title {
    font-size: 18px;
    font-weight: 600;
    color: var(--secondary-color);
}

.toolbar-group {
    display: flex;
    align-items: center;
    gap: 4px;
}

.toolbar-divider {
    width: 1px;
    height: 32px;
    background: var(--border-color);
    margin: 0 8px;
}

.toolbar-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 12px;
    border: none;
    background: transparent;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 13px;
    color: var(--text-primary);
    transition: all var(--transition-fast);
    white-space: nowrap;
}

.toolbar-btn:hover { background: var(--bg-color); }
.toolbar-btn:active { transform: scale(0.96); }
.toolbar-btn:disabled { opacity: 0.4; cursor: not-allowed; }
.toolbar-btn.primary { background: var(--primary-color); color: white; }
.toolbar-btn.primary:hover { background: var(--primary-dark); }
.toolbar-btn.danger:hover { background: #FFF0F0; color: var(--danger-color); }
.toolbar-btn.ai { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
.toolbar-btn .icon { font-size: 16px; }

.toolbar-select {
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    background: white;
    font-size: 13px;
    cursor: pointer;
    outline: none;
}

.zoom-display {
    min-width: 50px;
    text-align: center;
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 500;
}

/* 下拉菜单 */
.dropdown { position: relative; }

.dropdown-menu {
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 4px;
    min-width: 180px;
    background: white;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-lg);
    opacity: 0;
    visibility: hidden;
    transform: translateY(-10px);
    transition: all var(--transition-fast);
    z-index: 1001;
}

.dropdown:hover .dropdown-menu {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}

.dropdown-item {
    display: block;
    width: 100%;
    padding: 10px 16px;
    border: none;
    background: none;
    text-align: left;
    font-size: 13px;
    color: var(--text-primary);
    cursor: pointer;
}

.dropdown-item:hover { background: var(--bg-color); }
.dropdown-divider { height: 1px; background: var(--border-color); margin: 4px 0; }

/* ==================== 侧边栏 ==================== */
.sidebar {
    position: fixed;
    top: var(--toolbar-height);
    width: var(--sidebar-width);
    height: calc(100vh - var(--toolbar-height));
    background: var(--panel-bg);
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    transition: transform var(--transition-normal);
    z-index: 900;
}

.left-panel { left: 0; }
.left-panel.collapsed { transform: translateX(-100%); }
.right-panel { right: 0; }
.right-panel.collapsed { transform: translateX(100%); }

.panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-color);
}

.panel-header h3 { font-size: 14px; font-weight: 600; }

.panel-toggle {
    width: 28px;
    height: 28px;
    border: 1px solid var(--border-color);
    background: white;
    border-radius: 4px;
    cursor: pointer;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all var(--transition-fast);
}

.panel-toggle:hover { background: var(--primary-color); border-color: var(--primary-color); color: white; }

.panel-content {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
}

/* 侧边栏展开按钮 (悬浮) */
.panel-expand-btn {
    position: fixed;
    top: 50%;
    transform: translateY(-50%);
    width: 32px;
    height: 60px;
    background: white;
    border: 1px solid var(--border-color);
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 4px;
    font-size: 14px;
    color: var(--text-secondary);
    box-shadow: var(--shadow-md);
    z-index: 800;
    transition: all var(--transition-fast);
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
}

.panel-expand-btn:hover {
    background: var(--bg-color);
    color: var(--primary-color);
}

.panel-expand-btn.left {
    left: 0;
    border-left: none;
    border-radius: 0 8px 8px 0;
}

.panel-expand-btn.right {
    right: 0;
    border-right: none;
    border-radius: 8px 0 0 8px;
}

.panel-expand-btn.visible {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
}

/* 样式设置 */
.style-section { margin-bottom: 20px; }

.style-section h4 {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    margin-bottom: 12px;
}

.style-row { margin-bottom: 12px; }

.style-row label {
    display: block;
    font-size: 12px;
    color: var(--text-secondary);
    margin-bottom: 6px;
}

.style-row input[type="text"],
.style-row input[type="url"],
.style-row textarea,
.style-row select {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    font-size: 13px;
    outline: none;
}

.style-row input:focus,
.style-row select:focus { border-color: var(--primary-color); }

.style-row textarea { min-height: 60px; resize: vertical; }

.style-row input[type="range"] {
    width: calc(100% - 50px);
    vertical-align: middle;
}

.style-row .range-value {
    display: inline-block;
    width: 45px;
    text-align: right;
    font-size: 12px;
    color: var(--text-secondary);
}

.color-presets {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 8px;
}

.color-preset {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all var(--transition-fast);
}

.color-preset:hover { transform: scale(1.15); }
.color-preset.active { border-color: var(--text-primary); }

.icon-picker {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

.icon-option {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

.icon-option:hover { border-color: var(--primary-color); background: rgba(78, 205, 196, 0.1); }
.icon-option.active { background: var(--primary-color); border-color: var(--primary-color); color: white; }

/* ==================== 主画布 ==================== */
.canvas-container {
    position: fixed;
    top: var(--toolbar-height);
    left: var(--sidebar-width);
    right: var(--sidebar-width);
    bottom: 0;
    overflow: hidden;
    background: var(--canvas-bg);
    background-image: radial-gradient(circle, #ddd 1px, transparent 1px);
    background-size: 24px 24px;
    cursor: grab;
    transition: left var(--transition-normal), right var(--transition-normal);
}

.canvas-container.left-collapsed { left: 0; }
.canvas-container.right-collapsed { right: 0; }
.canvas-container:active { cursor: grabbing; }

.connections-layer,
.nodes-layer {
    position: absolute;
    top: 0;
    left: 0;
    transform-origin: 0 0;
}

.connections-layer {
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: visible;
}

.nodes-layer {
    min-width: 10000px;
    min-height: 10000px;
}

/* ==================== 节点样式 ==================== */
.mind-node {
    position: absolute;
    min-width: 60px;
    max-width: 350px;
    padding: 10px 18px;
    background: var(--primary-color);
    color: white;
    border-radius: var(--border-radius);
    cursor: pointer;
    user-select: none;
    box-shadow: var(--shadow-sm);
    transition: box-shadow var(--transition-fast), transform var(--transition-fast);
    display: flex;
    align-items: center;
    gap: 8px;
}

.mind-node:hover { box-shadow: var(--shadow-md); }
.mind-node.selected { box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.6), var(--shadow-md); }
.mind-node.multi-selected { box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.6), var(--shadow-md); }
.mind-node.dragging { opacity: 0.8; z-index: 1000; box-shadow: var(--shadow-lg); cursor: grabbing; }
.mind-node.drop-target { box-shadow: 0 0 0 3px var(--success-color), var(--shadow-md); }

.mind-node.root {
    background: var(--secondary-color);
    font-size: 18px;
    font-weight: 600;
    padding: 14px 28px;
}

.mind-node.level-1 { background: #3498DB; font-size: 15px; font-weight: 500; }
.mind-node.level-2 { background: #4ECDC4; }
.mind-node.level-3 { background: #96CEB4; color: var(--text-primary); }
.mind-node.level-4 { background: #FFEAA7; color: var(--text-primary); }

.mind-node.shape-rectangle { border-radius: 0; }
.mind-node.shape-ellipse { border-radius: 50px; }
.mind-node.shape-capsule { border-radius: 100px; }

.node-content {
    display: flex;
    align-items: center;
    gap: 8px;
    flex: 1;
}

.node-icon { font-size: 16px; flex-shrink: 0; }
.node-text { flex: 1; word-wrap: break-word; line-height: 1.4; }

.node-expand-btn {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.25);
    border: none;
    color: inherit;
    font-size: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}

.node-expand-btn:hover { background: rgba(255, 255, 255, 0.4); }

.node-badges {
    position: absolute;
    top: -6px;
    right: -6px;
    display: flex;
    gap: 2px;
}

.node-badge {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: white;
    box-shadow: var(--shadow-sm);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
}

.node-input {
    background: transparent;
    border: none;
    color: inherit;
    font-size: inherit;
    font-family: inherit;
    font-weight: inherit;
    outline: none;
    width: 100%;
    min-width: 50px;
}

/* 连接线 */
.connection-path {
    fill: none;
    stroke: #999;
    stroke-width: 2;
    stroke-linecap: round;
}

.connection-path.highlighted {
    stroke: var(--primary-color);
    stroke-width: 3;
}

/* 选择框 */
.selection-box {
    position: absolute;
    border: 2px dashed var(--primary-color);
    background: rgba(78, 205, 196, 0.1);
    pointer-events: none;
    display: none;
}

.selection-box.active { display: block; }

/* ==================== 小地图 ==================== */
.minimap {
    position: fixed;
    bottom: 20px;
    right: calc(var(--sidebar-width) + 20px);
    width: 180px;
    height: 120px;
    background: white;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-md);
    overflow: hidden;
    z-index: 500;
    transition: right var(--transition-normal);
}

.canvas-container.right-collapsed ~ .minimap,
.right-panel.collapsed ~ .minimap { right: 20px; }

.minimap canvas { width: 100%; height: 100%; }

.minimap-viewport {
    position: absolute;
    border: 2px solid var(--primary-color);
    background: rgba(78, 205, 196, 0.15);
    pointer-events: none;
}

/* 缩放提示 */
.zoom-hint {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    padding: 12px 24px;
    background: rgba(0, 0, 0, 0.75);
    color: white;
    border-radius: var(--border-radius);
    font-size: 18px;
    font-weight: 600;
    opacity: 0;
    visibility: hidden;
    transition: all var(--transition-fast);
    z-index: 1000;
    pointer-events: none;
}

.zoom-hint.visible {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1);
}

/* ==================== 右键菜单 ==================== */
.context-menu {
    position: fixed;
    min-width: 200px;
    background: white;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-lg);
    padding: 6px 0;
    z-index: 2000;
    opacity: 0;
    visibility: hidden;
    transform: scale(0.95);
    transition: all var(--transition-fast);
}

.context-menu.visible {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
}

.menu-item {
    display: flex;
    align-items: center;
    padding: 10px 16px;
    cursor: pointer;
    transition: background var(--transition-fast);
}

.menu-item:hover { background: var(--bg-color); }
.menu-item.danger { color: var(--danger-color); }
.menu-item.danger:hover { background: #FFF5F5; }

.menu-icon { width: 24px; font-size: 14px; }
.menu-text { flex: 1; font-size: 13px; }
.menu-shortcut { font-size: 11px; color: var(--text-light); margin-left: 16px; }
.menu-divider { height: 1px; background: var(--border-color); margin: 6px 0; }

/* ==================== 弹窗 ==================== */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 3000;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition: all var(--transition-normal);
}

.modal.visible { opacity: 1; visibility: visible; }

.modal-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
}

.modal-content {
    position: relative;
    width: 90%;
    max-width: 600px;
    max-height: 85vh;
    background: white;
    border-radius: 12px;
    box-shadow: var(--shadow-lg);
    transform: translateY(20px);
    transition: transform var(--transition-normal);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.modal.visible .modal-content { transform: translateY(0); }

.modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px;
    border-bottom: 1px solid var(--border-color);
}

.modal-header h2 { font-size: 18px; font-weight: 600; }

.modal-close {
    width: 32px;
    height: 32px;
    border: none;
    background: transparent;
    font-size: 24px;
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: 4px;
}

.modal-close:hover { background: var(--bg-color); color: var(--text-primary); }

.modal-body {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
}

.modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: 12px;
    padding: 16px 20px;
    border-top: 1px solid var(--border-color);
}

.form-group { margin-bottom: 16px; }
.form-group label { display: block; font-size: 14px; font-weight: 500; margin-bottom: 8px; }

.form-group textarea {
    width: 100%;
    min-height: 150px;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    font-size: 14px;
    line-height: 1.6;
    resize: vertical;
    outline: none;
}

.form-group textarea:focus { border-color: var(--primary-color); }

.form-group select {
    width: 100%;
    padding: 10px 12px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    font-size: 14px;
    outline: none;
}

.char-count {
    text-align: right;
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 6px;
}

.radio-group { display: flex; flex-direction: column; gap: 10px; }

.radio-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 14px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    cursor: pointer;
}

.radio-item:hover { border-color: var(--primary-color); }
.radio-item input { margin: 0; }
.radio-item span { font-weight: 500; }
.radio-item small { font-size: 12px; color: var(--text-secondary); margin-left: auto; }

.btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    border: none;
    border-radius: var(--border-radius);
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all var(--transition-fast);
}

.btn.primary {
    background: var(--primary-color);
    color: white;
}

.btn.primary:hover { background: var(--primary-dark); }

.btn.secondary {
    background: var(--bg-color);
    color: var(--text-primary);
}

.btn.secondary:hover { background: var(--border-color); }

/* ==================== 加载遮罩 ==================== */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 5000;
    opacity: 0;
    visibility: hidden;
    transition: all var(--transition-normal);
}

.loading-overlay.visible { opacity: 1; visibility: visible; }

.loading-content { text-align: center; }

.loading-spinner {
    width: 50px;
    height: 50px;
    border: 4px solid var(--border-color);
    border-top-color: var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 16px;
}

@keyframes spin { to { transform: rotate(360deg); } }

.loading-text {
    font-size: 16px;
    color: var(--text-primary);
}

/* ==================== Toast 提示 ==================== */
.toast-container {
    position: fixed;
    top: 80px;
    right: 20px;
    z-index: 4000;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.toast {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    background: white;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-lg);
    animation: toast-in 0.3s ease;
    max-width: 320px;
}

@keyframes toast-in {
    from { opacity: 0; transform: translateX(100%); }
    to { opacity: 1; transform: translateX(0); }
}

.toast.success { border-left: 4px solid var(--success-color); }
.toast.error { border-left: 4px solid var(--danger-color); }
.toast.warning { border-left: 4px solid var(--warning-color); }
.toast.info { border-left: 4px solid var(--primary-color); }

.toast-icon { font-size: 18px; }
.toast-message { flex: 1; font-size: 14px; }
.toast-close { background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 16px; padding: 0; }

/* ==================== 快捷键提示 ==================== */
.shortcuts-panel {
    position: fixed;
    bottom: 20px;
    left: calc(var(--sidebar-width) + 20px);
    background: white;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-md);
    padding: 12px 16px;
    font-size: 12px;
    z-index: 500;
    max-width: 200px;
    transition: left var(--transition-normal);
}

.canvas-container.left-collapsed ~ .shortcuts-panel { left: 20px; }

.shortcuts-panel h4 { font-size: 12px; margin-bottom: 8px; color: var(--text-secondary); }
.shortcuts-panel p { margin: 4px 0; color: var(--text-secondary); }
.shortcuts-panel kbd {
    background: var(--bg-color);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 11px;
}

/* ==================== 设置弹窗 ==================== */
.settings-notice {
    background: linear-gradient(135deg, #E8F5E9 0%, #F1F8E9 100%);
    border: 1px solid #C8E6C9;
    border-radius: var(--border-radius);
    padding: 14px;
    margin-bottom: 16px;
}

.settings-notice p { margin: 4px 0; font-size: 13px; color: #2E7D32; }

.api-status {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 14px;
    background: var(--bg-color);
    border-radius: var(--border-radius);
    margin-top: 12px;
}

.api-status .status-icon { font-size: 14px; }
.api-status .status-text { font-size: 13px; color: var(--text-secondary); }

/* 模型预设按钮 */
.model-preset-btn {
    padding: 6px 12px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    background: var(--bg-color);
    font-size: 12px;
    cursor: pointer;
    transition: all 0.15s ease;
    color: var(--text-primary);
}

.model-preset-btn:hover {
    border-color: var(--primary-color);
    background: rgba(78, 205, 196, 0.1);
    color: var(--primary-color);
}

/* ==================== 大纲视图 ==================== */
.outline-item {
    padding: 6px 8px;
    padding-left: calc(8px + var(--depth, 0) * 16px);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 13px;
}

.outline-item:hover { background: var(--bg-color); }
.outline-item.selected { background: rgba(78, 205, 196, 0.15); color: var(--primary-dark); }
.outline-item .expand-icon { width: 16px; font-size: 10px; color: var(--text-secondary); }

/* ==================== 暗黑模式 ==================== */
body.theme-dark {
    --bg-color: #1a1a2e;
    --panel-bg: #16213e;
    --canvas-bg: #0f0f23;
    --border-color: #2a2a4a;
    --text-primary: #E8E8E8;
    --text-secondary: #A0A0A0;
}

body.theme-dark .canvas-container {
    background-image: radial-gradient(circle, #333 1px, transparent 1px);
}

/* ==================== 响应式 ==================== */
@media (max-width: 1200px) {
    .left-panel, .right-panel { width: 220px; }
    .canvas-container { left: 220px; right: 220px; }
    .toolbar-btn .label { display: none; }
}

@media (max-width: 900px) {
    .left-panel { transform: translateX(-100%); }
    .right-panel { transform: translateX(100%); }
    .canvas-container { left: 0; right: 0; }
    .minimap { right: 20px; }
    .shortcuts-panel { left: 20px; }
}
    </style>
</head>
<body>
    <!-- ==================== 工具栏 ==================== -->
    <header class="toolbar">
        <div class="toolbar-brand">
            <span class="logo">🧠</span>
            <span class="title">MindFlow Pro</span>
        </div>
        
        <div class="toolbar-group">
            <button class="toolbar-btn" id="btn-new" title="新建">
                <span class="icon">📄</span>
                <span class="label">新建</span>
            </button>
            <button class="toolbar-btn" id="btn-save" title="保存">
                <span class="icon">💾</span>
                <span class="label">保存</span>
            </button>
            <button class="toolbar-btn" id="btn-load" title="打开">
                <span class="icon">📂</span>
                <span class="label">打开</span>
            </button>
        </div>

        <div class="toolbar-divider"></div>

        <div class="toolbar-group">
            <button class="toolbar-btn" id="btn-undo" title="撤销 (Ctrl+Z)" disabled>
                <span class="icon">↩️</span>
            </button>
            <button class="toolbar-btn" id="btn-redo" title="重做 (Ctrl+Y)" disabled>
                <span class="icon">↪️</span>
            </button>
        </div>

        <div class="toolbar-divider"></div>

        <div class="toolbar-group">
            <button class="toolbar-btn primary" id="btn-add-child" title="添加子节点 (Tab)">
                <span class="icon">➕</span>
                <span class="label">子节点</span>
            </button>
            <button class="toolbar-btn" id="btn-add-sibling" title="添加同级 (Enter)">
                <span class="icon">↔️</span>
                <span class="label">同级</span>
            </button>
            <button class="toolbar-btn danger" id="btn-delete" title="删除 (Delete)">
                <span class="icon">🗑️</span>
                <span class="label">删除</span>
            </button>
        </div>

        <div class="toolbar-divider"></div>

        <div class="toolbar-group">
            <button class="toolbar-btn ai" id="btn-ai-generate" title="AI生成思维导图">
                <span class="icon">🤖</span>
                <span class="label">AI生成</span>
            </button>
            <button class="toolbar-btn ai" id="btn-ai-analyze" title="AI分析文本">
                <span class="icon">📊</span>
                <span class="label">分析</span>
            </button>
        </div>

        <div class="toolbar-divider"></div>

        <div class="toolbar-group">
            <select class="toolbar-select" id="theme-select" title="主题">
                <option value="business">商务蓝</option>
                <option value="fresh">清新绿</option>
                <option value="dark">暗黑模式</option>
                <option value="colorful">多彩主题</option>
                <option value="minimal">极简白</option>
            </select>
        </div>

        <div class="toolbar-divider"></div>

        <div class="toolbar-group">
            <button class="toolbar-btn" id="btn-zoom-out" title="缩小">🔍-</button>
            <span class="zoom-display" id="zoom-level">100%</span>
            <button class="toolbar-btn" id="btn-zoom-in" title="放大">🔍+</button>
            <button class="toolbar-btn" id="btn-zoom-fit" title="适应屏幕">⛶</button>
        </div>

        <div class="toolbar-divider"></div>

        <div class="toolbar-group">
            <div class="dropdown">
                <button class="toolbar-btn">
                    <span class="icon">📤</span>
                    <span class="label">导出</span>
                    <span>▼</span>
                </button>
                <div class="dropdown-menu">
                    <button class="dropdown-item" data-export="png">📷 PNG 图片</button>
                    <button class="dropdown-item" data-export="jpg">🖼️ JPG 图片</button>
                    <div class="dropdown-divider"></div>
                    <button class="dropdown-item" data-export="json">💾 JSON 数据</button>
                    <button class="dropdown-item" data-export="markdown">📝 Markdown</button>
                    <button class="dropdown-item" data-export="txt">📄 纯文本</button>
                </div>
            </div>
        </div>

        <div class="toolbar-divider"></div>

        <div class="toolbar-group">
            <button class="toolbar-btn" id="btn-settings" title="设置">
                <span class="icon">⚙️</span>
                <span class="label">设置</span>
            </button>
        </div>
    </header>

    <!-- ==================== 左侧面板 - 大纲视图 ==================== -->
    <aside class="sidebar left-panel" id="left-panel">
        <div class="panel-header">
            <h3>📋 大纲视图</h3>
            <button class="panel-toggle" data-panel="left">◀</button>
        </div>
        <div class="panel-content">
            <div class="outline-tree" id="outline-tree"></div>
        </div>
    </aside>

    <!-- ==================== 主画布 ==================== -->
    <main class="canvas-container" id="canvas-container">
        <svg class="connections-layer" id="connections-svg"></svg>
        <div class="nodes-layer" id="nodes-layer"></div>
        <div class="selection-box" id="selection-box"></div>
        
        <!-- 侧边栏展开按钮 -->
        <button class="panel-expand-btn left" id="expand-left-panel" title="展开大纲">
            <span>📋</span>
            <span>▶</span>
        </button>
        <button class="panel-expand-btn right" id="expand-right-panel" title="展开样式">
            <span>◀</span>
            <span>🎨</span>
        </button>
    </main>

    <!-- ==================== 右侧面板 - 样式设置 ==================== -->
    <aside class="sidebar right-panel" id="right-panel">
        <div class="panel-header">
            <h3>🎨 样式设置</h3>
            <button class="panel-toggle" data-panel="right">▶</button>
        </div>
        <div class="panel-content">
            <section class="style-section">
                <h4>节点样式</h4>
                
                <div class="style-row">
                    <label>形状</label>
                    <select id="node-shape">
                        <option value="rounded">圆角矩形</option>
                        <option value="rectangle">矩形</option>
                        <option value="ellipse">椭圆</option>
                        <option value="capsule">胶囊</option>
                    </select>
                </div>
                
                <div class="style-row">
                    <label>背景色</label>
                    <input type="color" id="node-bg-color" value="#4ECDC4">
                    <div class="color-presets" id="bg-presets"></div>
                </div>
                
                <div class="style-row">
                    <label>文字颜色</label>
                    <input type="color" id="node-text-color" value="#ffffff">
                </div>
                
                <div class="style-row">
                    <label>字体大小</label>
                    <input type="range" id="node-font-size" min="12" max="28" value="14">
                    <span class="range-value" id="font-size-value">14px</span>
                </div>
            </section>

            <section class="style-section">
                <h4>图标</h4>
                <div class="icon-picker" id="icon-picker">
                    <span class="icon-option" data-icon="">无</span>
                    <span class="icon-option" data-icon="⭐">⭐</span>
                    <span class="icon-option" data-icon="❗">❗</span>
                    <span class="icon-option" data-icon="✅">✅</span>
                    <span class="icon-option" data-icon="❌">❌</span>
                    <span class="icon-option" data-icon="🔥">🔥</span>
                    <span class="icon-option" data-icon="💡">💡</span>
                    <span class="icon-option" data-icon="📌">📌</span>
                    <span class="icon-option" data-icon="🎯">🎯</span>
                    <span class="icon-option" data-icon="⚠️">⚠️</span>
                    <span class="icon-option" data-icon="📝">📝</span>
                    <span class="icon-option" data-icon="💰">💰</span>
                    <span class="icon-option" data-icon="👤">👤</span>
                    <span class="icon-option" data-icon="📊">📊</span>
                    <span class="icon-option" data-icon="🔗">🔗</span>
                </div>
            </section>

            <section class="style-section">
                <h4>备注</h4>
                <div class="style-row">
                    <textarea id="node-note" placeholder="添加备注..."></textarea>
                </div>
            </section>

            <section class="style-section">
                <h4>链接</h4>
                <div class="style-row">
                    <input type="url" id="node-link" placeholder="https://...">
                </div>
            </section>
        </div>
    </aside>

    <!-- ==================== 小地图 ==================== -->
    <div class="minimap" id="minimap">
        <canvas id="minimap-canvas"></canvas>
        <div class="minimap-viewport" id="minimap-viewport"></div>
    </div>

    <!-- ==================== 快捷键提示 ==================== -->
    <div class="shortcuts-panel" id="shortcuts-panel">
        <h4>⌨️ 快捷键</h4>
        <p><kbd>Tab</kbd> 添加子节点</p>
        <p><kbd>Enter</kbd> 添加同级</p>
        <p><kbd>Delete</kbd> 删除</p>
        <p><kbd>F2</kbd> 编辑</p>
        <p><kbd>Space</kbd> 展开/折叠</p>
    </div>

    <!-- ==================== 缩放提示 ==================== -->
    <div class="zoom-hint" id="zoom-hint">100%</div>

    <!-- ==================== 右键菜单 ==================== -->
    <div class="context-menu" id="context-menu">
        <div class="menu-item" data-action="add-child">
            <span class="menu-icon">➕</span>
            <span class="menu-text">添加子节点</span>
            <span class="menu-shortcut">Tab</span>
        </div>
        <div class="menu-item" data-action="add-sibling">
            <span class="menu-icon">↔️</span>
            <span class="menu-text">添加同级节点</span>
            <span class="menu-shortcut">Enter</span>
        </div>
        <div class="menu-divider"></div>
        <div class="menu-item" data-action="edit">
            <span class="menu-icon">✏️</span>
            <span class="menu-text">编辑</span>
            <span class="menu-shortcut">F2</span>
        </div>
        <div class="menu-item" data-action="copy">
            <span class="menu-icon">📋</span>
            <span class="menu-text">复制</span>
            <span class="menu-shortcut">Ctrl+C</span>
        </div>
        <div class="menu-item" data-action="paste">
            <span class="menu-icon">📄</span>
            <span class="menu-text">粘贴</span>
            <span class="menu-shortcut">Ctrl+V</span>
        </div>
        <div class="menu-divider"></div>
        <div class="menu-item" data-action="expand-all">
            <span class="menu-icon">📂</span>
            <span class="menu-text">展开所有</span>
        </div>
        <div class="menu-item" data-action="collapse-all">
            <span class="menu-icon">📁</span>
            <span class="menu-text">折叠所有</span>
        </div>
        <div class="menu-divider"></div>
        <div class="menu-item" data-action="ai-expand">
            <span class="menu-icon">🤖</span>
            <span class="menu-text">AI扩展此节点</span>
        </div>
        <div class="menu-divider"></div>
        <div class="menu-item danger" data-action="delete">
            <span class="menu-icon">🗑️</span>
            <span class="menu-text">删除</span>
            <span class="menu-shortcut">Delete</span>
        </div>
    </div>

    <!-- ==================== AI生成弹窗 ==================== -->
    <!-- 面板一：本地分析面板（无API） -->
    <div class="modal" id="analyze-modal">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <div class="modal-header">
                <h2>📊 本地智能分析</h2>
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div style="background:#f0f7ff;border-left:4px solid #0066cc;padding:12px;margin-bottom:16px;border-radius:4px;">
                    <strong>💡 本地分析（无需API）</strong><br>
                    <small style="color:#555;">粘贴文本或列表，AI本地智能提取结构。支持多种分析视角。</small>
                </div>
                
                <div class="form-group">
                    <label>输入文本或列表</label>
                    <textarea id="analyze-input" placeholder="粘贴您的文本、文章、笔记或列表项...&#10;支持：长段落、逐行列表、要点提纲等"></textarea>
                    <div class="char-count"><span id="analyze-char-count">0</span> 字</div>
                </div>
                
                <div class="form-group">
                    <label>分析视角</label>
                    <select id="analyze-type">
                        <option value="business">📈 业务架构分析</option>
                        <option value="technical">⚙️ 技术架构分析</option>
                        <option value="system">🔗 系统架构分析</option>
                        <option value="data">📊 数据架构分析</option>
                        <option value="organization">👥 组织架构分析</option>
                    </select>
                    <small style="color:#666;font-size:12px;margin-top:4px;display:block;">
                        选择不同视角改变本地分析的关注点
                    </small>
                </div>

                <div class="form-group">
                    <label>模板风格（可选）</label>
                    <select id="analyze-template">
                        <option value="general">通用结构</option>
                        <option value="product">产品规划</option>
                        <option value="project">项目管理</option>
                        <option value="business">商业分析</option>
                        <option value="research">研究报告</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn secondary" id="btn-analyze-cancel">取消</button>
                <button class="btn primary" id="btn-analyze-submit">🔍 开始分析</button>
            </div>
        </div>
    </div>

    <!-- 面板二：API智能生成面板 -->
    <div class="modal" id="ai-generate-modal">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <div class="modal-header">
                <h2>🚀 AI智能生成</h2>
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div style="background:#fff3e0;border-left:4px solid #ff9800;padding:12px;margin-bottom:16px;border-radius:4px;">
                    <strong>⚡ API智能生成（需配置API）</strong><br>
                    <small style="color:#555;">输入主题或问题，AI大模型深度理解并生成详尽的多层结构。支持创意头脑风暴、多角度分析、内容深化等高级功能。</small>
                </div>

                <div class="form-group">
                    <label>输入主题或问题</label>
                    <textarea id="ai-input" placeholder="输入关键词或简短描述，例如：&#10;• 项目管理系统的架构设计&#10;• 如何提升团队协作效率&#10;• 新产品上市的营销策略&#10;AI将自动生成详尽的多层思维导图..."></textarea>
                    <div class="char-count"><span id="char-count">0</span> 字</div>
                </div>
                
                <div class="form-group">
                    <label>生成模板</label>
                    <select id="ai-template">
                        <option value="general">📋 通用结构</option>
                        <option value="product">📦 产品规划</option>
                        <option value="project">📅 项目管理</option>
                        <option value="business">💼 商业分析</option>
                        <option value="research">🔬 研究报告</option>
                        <option value="learning">📚 学习笔记</option>
                        <option value="decision">🎯 决策分析</option>
                    </select>
                    <small style="color:#666;font-size:12px;margin-top:4px;display:block;">
                        选择模板改变AI的组织方式和深度
                    </small>
                </div>

                <div class="form-group">
                    <label>高级选项</label>
                    <div style="display:flex;gap:12px;flex-wrap:wrap;">
                        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;flex:1;min-width:150px;">
                            <input type="checkbox" id="ai-enable-brainstorm" checked>
                            <small>头脑风暴</small>
                        </label>
                        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;flex:1;min-width:150px;">
                            <input type="checkbox" id="ai-enable-multiangle" checked>
                            <small>多角度分析</small>
                        </label>
                        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;flex:1;min-width:150px;">
                            <input type="checkbox" id="ai-enable-examples" checked>
                            <small>补充案例</small>
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn secondary" id="btn-ai-cancel">取消</button>
                <button class="btn primary" id="btn-ai-submit">✨ 开始生成</button>
            </div>
        </div>
    </div>

    <!-- ==================== 设置弹窗 (修复API设置) ==================== -->
    <div class="modal" id="settings-modal">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <div class="modal-header">
                <h2>⚙️ API设置（可选）</h2>
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-notice">
                    <p>💡 <strong>不配置API也能正常使用！</strong></p>
                    <p>本地模式已包含完整功能。配置API后效果更智能。</p>
                </div>
                
                <div class="form-group">
                    <label>API 主机地址</label>
                    <input type="text" id="setting-api-host" placeholder="https://api.openai.com">
                    <small style="color:#666;font-size:12px;margin-top:4px;display:block;">
                        仅填写主机地址，示例：<br>
                        • OpenAI: https://api.openai.com<br>
                        • Claude: https://api.anthropic.com<br>
                        • 通义千问: https://dashscope.aliyuncs.com<br>
                        • 本地Ollama: http://localhost:11434
                    </small>
                </div>
                
                <div class="form-group">
                    <label>API 路径（默认 /v1/chat/completions）</label>
                    <input type="text" id="setting-api-path" placeholder="/v1/chat/completions">
                    <small style="color:#666;font-size:12px;margin-top:4px;display:block;">
                        API 端点路径，示例：<br>
                        • OpenAI/DeepSeek: /v1/chat/completions<br>
                        • Claude: /v1/messages<br>
                        • 通义千问: /api/v1/services/aigc/text-generation/generation<br>
                        • 本地Ollama: /api/chat
                    </small>
                </div>
                
                <div class="form-group">
                    <label>API 密钥</label>
                    <input type="password" id="setting-api-key" placeholder="sk-...">
                    <small style="color:#666;font-size:12px;margin-top:4px;display:block;">本地Ollama 可以留空</small>
                </div>
                
                <div class="form-group">
                    <label>模型名称</label>
                    <input type="text" id="setting-model" placeholder="例如：gpt-4, claude-3-opus, qwen-turbo...">
                    <small style="color:#666;font-size:12px;margin-top:4px;display:block;">直接填写你的API支持的模型ID</small>
                </div>
                
                <div class="form-group">
                    <label>常用模型快捷填入</label>
                    <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:8px;">
                        <button type="button" class="model-preset-btn" data-model="gpt-4">GPT-4</button>
                        <button type="button" class="model-preset-btn" data-model="gpt-4-turbo">GPT-4 Turbo</button>
                        <button type="button" class="model-preset-btn" data-model="gpt-3.5-turbo">GPT-3.5</button>
                        <button type="button" class="model-preset-btn" data-model="claude-3-opus-20240229">Claude 3 Opus</button>
                        <button type="button" class="model-preset-btn" data-model="claude-3-sonnet-20240229">Claude 3 Sonnet</button>
                        <button type="button" class="model-preset-btn" data-model="qwen-turbo">通义千问</button>
                        <button type="button" class="model-preset-btn" data-model="deepseek-chat">DeepSeek</button>
                    </div>
                </div>
                
                <div class="api-status" id="api-status">
                    <span class="status-icon">⚪</span>
                    <span class="status-text">未配置API，使用本地模式</span>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn secondary" id="btn-test-api">🔍 测试连接</button>
                <button class="btn secondary" id="btn-clear-config">清除配置</button>
                <button class="btn primary" id="btn-save-settings">💾 保存设置</button>
            </div>
        </div>
    </div>

    <!-- ==================== 加载遮罩 ==================== -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loading-text">处理中...</div>
        </div>
    </div>

    <!-- ==================== Toast容器 ==================== -->
    <div class="toast-container" id="toast-container"></div>

    <!-- ==================== 文件输入 ==================== -->
    <input type="file" id="file-input" accept=".json,.txt,.md" style="display:none">

    <!-- ==================== JavaScript ==================== -->
    <script>
// ==================== 节点类 ====================
class Node {
    constructor(options = {}) {
        this.id = options.id || ('node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
        this.text = options.text || '新节点';
        this.note = options.note || '';
        this.link = options.link || '';
        this.icon = options.icon || '';
        this.parentId = options.parentId || null;
        this.children = [];
        this.x = options.x || 0;
        this.y = options.y || 0;
        this.width = 0;
        this.height = 0;
        this.expanded = options.expanded !== false;
        this.selected = false;
        this.editing = false;
        this.element = null;
        
        this.style = {
            backgroundColor: options.style?.backgroundColor || null,
            textColor: options.style?.textColor || null,
            fontSize: options.style?.fontSize || null,
            shape: options.style?.shape || 'rounded',
            ...options.style
        };
        
        if (options.children && Array.isArray(options.children)) {
            options.children.forEach(childData => {
                const child = new Node(childData);
                child.parentId = this.id;
                this.children.push(child);
            });
        }
    }
    
    addChild(nodeOrOptions, index = -1) {
        const child = nodeOrOptions instanceof Node ? nodeOrOptions : new Node(nodeOrOptions);
        child.parentId = this.id;
        if (index >= 0 && index < this.children.length) {
            this.children.splice(index, 0, child);
        } else {
            this.children.push(child);
        }
        return child;
    }
    
    removeChild(childId) {
        const index = this.children.findIndex(c => c.id === childId);
        if (index !== -1) {
            const removed = this.children.splice(index, 1)[0];
            removed.parentId = null;
            return removed;
        }
        return null;
    }
    
    isRoot() { return this.parentId === null; }
    hasChildren() { return this.children.length > 0; }
    
    toggleExpand() {
        this.expanded = !this.expanded;
        return this.expanded;
    }
    
    expandAll() {
        this.expanded = true;
        this.children.forEach(child => child.expandAll());
    }
    
    collapseAll() {
        this.expanded = false;
        this.children.forEach(child => child.collapseAll());
    }
    
    getTotalChildCount() {
        let count = this.children.length;
        for (const child of this.children) {
            count += child.getTotalChildCount();
        }
        return count;
    }
    
    clone(deep = true) {
        const cloned = new Node({
            text: this.text,
            note: this.note,
            link: this.link,
            icon: this.icon,
            style: { ...this.style },
            expanded: this.expanded
        });
        if (deep) {
            cloned.children = this.children.map(child => {
                const clonedChild = child.clone(true);
                clonedChild.parentId = cloned.id;
                return clonedChild;
            });
        }
        return cloned;
    }
    
    toJSON() {
        return {
            id: this.id,
            text: this.text,
            note: this.note,
            link: this.link,
            icon: this.icon,
            style: this.style,
            expanded: this.expanded,
            children: this.children.map(child => child.toJSON())
        };
    }
    
    static fromJSON(json) {
        return new Node(json);
    }
    
    toMarkdown(level = 0) {
        let md = '';
        const prefix = level === 0 ? '# ' : '  '.repeat(level - 1) + '- ';
        md += prefix + (this.icon ? this.icon + ' ' : '') + this.text;
        if (this.note) md += '\n' + '  '.repeat(level) + '> ' + this.note;
        if (this.link) md += ` [🔗](${this.link})`;
        md += '\n';
        for (const child of this.children) {
            md += child.toMarkdown(level + 1);
        }
        return md;
    }
    
    toText(level = 0) {
        let text = '';
        const indent = '    '.repeat(level);
        text += indent + (level > 0 ? '├── ' : '') + this.text + '\n';
        for (const child of this.children) {
            text += child.toText(level + 1);
        }
        return text;
    }
}

// ==================== 布局算法 ====================
class Layout {
    constructor(options = {}) {
        this.config = {
            horizontalSpacing: 80,
            verticalSpacing: 16,
            levelIndentDecay: 0.92,
            minHorizontalSpacing: 50,
            rootX: 300,
            ...options
        };
        this.subtreeHeights = new Map();
    }
    
    calculate(root, canvasHeight = 800) {
        this.subtreeHeights.clear();
        this.calculateSubtreeHeight(root);
        root.x = this.config.rootX;
        root.y = canvasHeight / 2 - 25;
        this.layoutChildren(root, 0);
        return root;
    }
    
    calculateSubtreeHeight(node) {
        if (!node.expanded || node.children.length === 0) {
            const height = 45;
            this.subtreeHeights.set(node.id, height);
            return height;
        }
        let totalHeight = 0;
        for (const child of node.children) {
            totalHeight += this.calculateSubtreeHeight(child);
        }
        totalHeight += (node.children.length - 1) * this.config.verticalSpacing;
        const height = Math.max(totalHeight, 45);
        this.subtreeHeights.set(node.id, height);
        return height;
    }
    
    layoutChildren(parent, depth) {
        if (!parent.expanded || parent.children.length === 0) return;
        
        const levelSpacing = Math.max(
            this.config.minHorizontalSpacing,
            this.config.horizontalSpacing * Math.pow(this.config.levelIndentDecay, depth)
        );
        
        const parentWidth = parent.width || (parent.isRoot() ? 160 : 120);
        const childX = parent.x + parentWidth + levelSpacing;
        
        let totalHeight = 0;
        const childHeights = [];
        for (const child of parent.children) {
            const h = this.subtreeHeights.get(child.id) || 45;
            childHeights.push(h);
            totalHeight += h;
        }
        totalHeight += (parent.children.length - 1) * this.config.verticalSpacing;
        
        const parentHeight = parent.height || 45;
        let currentY = parent.y + parentHeight / 2 - totalHeight / 2;
        
        for (let i = 0; i < parent.children.length; i++) {
            const child = parent.children[i];
            const childHeight = childHeights[i];
            child.x = childX;
            child.y = currentY + childHeight / 2 - 22;
            currentY += childHeight + this.config.verticalSpacing;
            this.layoutChildren(child, depth + 1);
        }
    }
    
    getConnectionPath(parent, child) {
        const parentWidth = parent.width || (parent.isRoot() ? 160 : 120);
        const parentHeight = parent.height || 45;
        const childHeight = child.height || 40;
        
        const startX = parent.x + parentWidth;
        const startY = parent.y + parentHeight / 2;
        const endX = child.x;
        const endY = child.y + childHeight / 2;
        const cpX = (startX + endX) / 2;
        
        return `M ${startX} ${startY} C ${cpX} ${startY}, ${cpX} ${endY}, ${endX} ${endY}`;
    }
}

// ==================== 主题管理 ====================
class Themes {
    constructor() {
        this.themes = {
            business: {
                name: '商务蓝',
                colors: ['#2C3E50', '#3498DB', '#5DADE2', '#85C1E9', '#AED6F1'],
                lineColor: '#7F8C8D',
                background: '#F8FAFE'
            },
            fresh: {
                name: '清新绿',
                colors: ['#1E8449', '#27AE60', '#2ECC71', '#58D68D', '#82E0AA'],
                lineColor: '#7DCEA0',
                background: '#F0FFF4'
            },
            dark: {
                name: '暗黑模式',
                colors: ['#2C3E50', '#34495E', '#5D6D7E', '#85929E', '#ABB2B9'],
                lineColor: '#5D6D7E',
                background: '#1a1a2e'
            },
            colorful: {
                name: '多彩主题',
                colors: ['#9B59B6', '#E74C3C', '#F39C12', '#27AE60', '#3498DB'],
                lineColor: '#95A5A6',
                background: '#FFFFFF'
            },
            minimal: {
                name: '极简白',
                colors: ['#2C3E50', '#34495E', '#7F8C8D', '#BDC3C7', '#ECF0F1'],
                lineColor: '#BDC3C7',
                background: '#FFFFFF'
            }
        };
        this.currentTheme = 'business';
    }
    
    getTheme(name) {
        return this.themes[name] || this.themes.business;
    }
    
    getCurrentTheme() {
        return this.themes[this.currentTheme];
    }
    
    setTheme(name) {
        if (this.themes[name]) {
            this.currentTheme = name;
            document.body.className = '';
            if (name === 'dark') {
                document.body.classList.add('theme-dark');
            }
            return this.themes[name];
        }
        return null;
    }
    
    getColorForDepth(depth) {
        const colors = this.getCurrentTheme().colors;
        return colors[Math.min(depth, colors.length - 1)];
    }
}

// ==================== 历史记录 ====================
class History {
    constructor(maxSize = 50) {
        this.undoStack = [];
        this.redoStack = [];
        this.maxSize = maxSize;
        this.onChange = null;
    }
    
    push(state, description = '') {
        this.redoStack = [];
        this.undoStack.push({
            state: JSON.parse(JSON.stringify(state)),
            description,
            timestamp: Date.now()
        });
        if (this.undoStack.length > this.maxSize) {
            this.undoStack.shift();
        }
        this.notify();
    }
    
    undo(currentState) {
        if (!this.canUndo()) return null;
        this.redoStack.push({
            state: JSON.parse(JSON.stringify(currentState)),
            timestamp: Date.now()
        });
        const previous = this.undoStack.pop();
        this.notify();
        return previous.state;
    }
    
    redo(currentState) {
        if (!this.canRedo()) return null;
        this.undoStack.push({
            state: JSON.parse(JSON.stringify(currentState)),
            timestamp: Date.now()
        });
        const next = this.redoStack.pop();
        this.notify();
        return next.state;
    }
    
    canUndo() { return this.undoStack.length > 0; }
    canRedo() { return this.redoStack.length > 0; }
    
    clear() {
        this.undoStack = [];
        this.redoStack = [];
        this.notify();
    }
    
    notify() {
        if (typeof this.onChange === 'function') {
            this.onChange({
                canUndo: this.canUndo(),
                canRedo: this.canRedo()
            });
        }
    }
}
// ==================== 文本分析器 ====================
class TextAnalyzer {
    constructor() {
        this.stopWords = new Set(['的', '了', '着', '是', '在', '把', '被', '让', '给', '就', '都', '也', '还', '又', '才', '只', '而', '且', '这', '那', '它', '他', '她', '我', '你', '们', '吧', '呢', '啊', '呀', '哦', '嗯']);
    }
    
    analyze(text, options = {}) {
        if (!text || text.trim().length === 0) {
            return { text: '请输入内容', children: [] };
        }
        
        const cleanedText = this.preprocess(text);
        const profile = this.profileText(cleanedText);
        
        let result;
        if (profile.hasHeadings || profile.hasNumberedList) {
            result = this.analyzeStructuredText(cleanedText, profile);
        } else if (profile.hasBulletList) {
            result = this.analyzeListText(cleanedText, profile);
        } else if (cleanedText.length < 200) {
            result = this.analyzeShortText(cleanedText, profile);
        } else {
            result = this.analyzeGenericText(cleanedText, profile);
        }
        
        return this.refineResult(result);
    }
    
    preprocess(text) {
        return text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/[ \t]+/g, ' ').replace(/\n{3,}/g, '\n\n').trim();
    }
    
    profileText(text) {
        return {
            length: text.length,
            paragraphs: text.split(/\n\n+/).filter(p => p.trim()),
            hasNumberedList: /^\s*[\d一二三四五六七八九十]+[.、．:：)\]】]\s*/m.test(text),
            hasBulletList: /^\s*[-*•·]\s+/m.test(text),
            hasHeadings: /^#+\s+|^[一二三四五六七八九十]+[、.]\s*\S|^\d+[.、]\s*[^\d]/m.test(text),
            topics: this.extractTopics(text)
        };
    }
    
    extractTopics(text) {
        const firstSentence = text.split(/[。！？\n]/)[0] || '';
        return [{ text: this.formatNodeText(firstSentence) || '主题', confidence: 0.8 }];
    }
    
    analyzeStructuredText(text, profile) {
        const sections = this.extractSections(text);
        const rootText = this.determineRootTopic(profile);
        
        if (sections.length === 0) {
            return this.analyzeGenericText(text, profile);
        }
        
        return {
            text: rootText,
            children: sections.map(section => ({
                text: this.formatNodeText(section.title),
                children: this.analyzeContent(section.content)
            }))
        };
    }
    
    extractSections(text) {
        const sections = [];
        const lines = text.split('\n');
        let currentSection = null;
        
        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;
            
            const isHeading = /^#{1,3}\s+/.test(trimmed) ||
                            /^[一二三四五六七八九十]+[、.．]\s*/.test(trimmed) ||
                            /^\d+[.、．]\s*/.test(trimmed);
            
            if (isHeading) {
                if (currentSection) sections.push(currentSection);
                const title = trimmed.replace(/^#{1,3}\s+/, '')
                                    .replace(/^[一二三四五六七八九十]+[、.．]\s*/, '')
                                    .replace(/^\d+[.、．]\s*/, '');
                currentSection = { title, content: '' };
            } else if (currentSection) {
                currentSection.content += trimmed + '\n';
            }
        }
        
        if (currentSection) sections.push(currentSection);
        return sections;
    }
    
    analyzeListText(text, profile) {
        const items = this.extractListItems(text);
        const rootText = this.determineRootTopic(profile);
        
        // 为列表项添加二级内容，而不是返回空children
        return {
            text: rootText,
            children: items.slice(0, 5).map(item => ({
                text: this.formatNodeText(item),
                children: [
                    { text: item + '的具体内容', children: [] },
                    { text: item + '的关键要点', children: [] }
                ]
            })).filter(n => n.text)
        };
    }
    
    extractListItems(text) {
        const items = [];
        const lines = text.split('\n');
        
        for (const line of lines) {
            const match = line.match(/^\s*[-*•·]\s+(.+)$/);
            if (match) {
                items.push(match[1].trim());
            }
        }
        
        return items;
    }
    
    analyzeShortText(text, profile) {
        const rootText = this.formatNodeText(text) || '主题';
        // 短文本也要拆分出多个维度，而不是返回空children
        const sentences = text.split(/[，、。！？\n]+/).filter(s => s.trim().length > 2);
        
        if (sentences.length === 0) {
            // 即使没有句子，也生成几个标准分支
            return {
                text: rootText,
                children: [
                    { text: rootText + '的核心定义', children: [] },
                    { text: rootText + '的主要特点', children: [] },
                    { text: rootText + '的应用价值', children: [] }
                ]
            };
        }
        
        return {
            text: rootText,
            children: sentences.slice(0, 4).map(s => ({
                text: this.formatNodeText(s) || '内容',
                children: []
            })).filter(n => n.text)
        };
    }
    
    analyzeGenericText(text, profile) {
        const rootText = this.determineRootTopic(profile);
        const layers = this.buildStructure(text, profile);
        
        return {
            text: rootText,
            children: Object.entries(layers)
                .filter(([_, items]) => items.length > 0)
                .map(([name, items]) => ({
                    text: name,
                    children: items.map(item => ({ text: item, children: [] }))
                }))
        };
    }
    
    buildStructure(text, profile) {
        const layers = {
            '核心要点': [],
            '主要内容': [],
            '补充说明': []
        };
        
        const sentences = text.split(/[。！？\n]+/).filter(s => s.trim().length > 5);
        
        sentences.forEach((sentence, index) => {
            const formatted = this.formatNodeText(sentence);
            if (!formatted) return;
            
            if (index < 2) {
                layers['核心要点'].push(formatted);
            } else if (index < 5) {
                layers['主要内容'].push(formatted);
            } else if (layers['补充说明'].length < 3) {
                layers['补充说明'].push(formatted);
            }
        });
        
        Object.keys(layers).forEach(key => {
            if (layers[key].length === 0) delete layers[key];
        });
        
        return layers;
    }
    
    analyzeContent(content) {
        if (!content || content.trim().length === 0) return [];
        
        const sentences = content.split(/[。！？\n]+/).filter(s => s.trim().length > 4);
        return sentences.slice(0, 4).map(s => ({
            text: this.formatNodeText(s),
            children: []
        })).filter(n => n.text);
    }
    
    determineRootTopic(profile) {
        if (profile.topics && profile.topics.length > 0) {
            return profile.topics[0].text;
        }
        if (profile.paragraphs && profile.paragraphs.length > 0) {
            const first = profile.paragraphs[0].split(/[。！？]/)[0];
            return this.formatNodeText(first) || '主题分析';
        }
        return '主题分析';
    }
    
    formatNodeText(text) {
        if (!text) return '';
        let formatted = text.trim();
        formatted = formatted.replace(/^[\d一二三四五六七八九十]+[.、．:：)\]】]\s*/g, '');
        formatted = formatted.replace(/^[-*•·]\s*/g, '');
        formatted = formatted.replace(/^["「『"']\s*/g, '');
        formatted = formatted.replace(/\s*["」』"']$/g, '');
        
        if (formatted.length > 40) {
            const comma = formatted.indexOf('，');
            if (comma > 8 && comma < 35) {
                formatted = formatted.substring(0, comma);
            } else {
                formatted = formatted.substring(0, 35) + '...';
            }
        }
        
        if (formatted.length < 2) return '';
        formatted = formatted.replace(/[，、。！？；：]+$/g, '');
        return formatted;
    }
    
    refineResult(result) {
        const removeEmpty = (node) => {
            if (!node || !node.text || node.text.length < 2) return null;
            if (node.children) {
                node.children = node.children.map(removeEmpty).filter(Boolean);
            }
            return node;
        };
        return removeEmpty(result) || { text: '分析结果', children: [] };
    }
}

// ==================== AI服务 ====================
class AIService {
    constructor() {
        this.apiHost = null;      // API 主机地址，如 https://api.openai.com
        this.apiPath = '/v1/chat/completions';  // API 路径，默认 /v1/chat/completions
        this.apiKey = null;
        this.model = 'gpt-4';
        this.timeout = 30000;
        this.textAnalyzer = new TextAnalyzer();
        this.apiEnabled = false;
    }
    
    configure(config) {
        this.apiHost = config.apiHost || null;
        this.apiPath = config.apiPath || '/v1/chat/completions';  // 如果没提供，使用默认值
        this.apiKey = config.apiKey || null;
        this.model = config.model || 'gpt-4';
        this.apiEnabled = !!(this.apiHost && this.apiKey);
    }
    
    getFullUrl() {
        if (!this.apiHost) return null;
        // 去掉 host 末尾的 / 和 path 开头的 /，然后拼接
        const host = this.apiHost.replace(/\/$/, '');
        const path = this.apiPath.startsWith('/') ? this.apiPath : '/' + this.apiPath;
        return host + path;
    }
    
    async generateFromTopic(topic, options = {}) {
        const { template = 'general' } = options;
        
        console.log('\n🤖 [生成] ========== 开始生成 ==========');
        console.log('📌 主题:', topic);
        console.log('📋 模板:', template);
        console.log('🔐 API启用状态:', this.apiEnabled);
        console.log('🔑 API配置:', { host: this.apiHost, model: this.model });
        
        if (this.apiEnabled) {
            try {
                console.log('🔌 [生成] 调用API生成...');
                const result = await this.callAPI(this.buildTopicPrompt(topic, template));
                if (result && result.text) {
                    console.log('✅ [生成] API 生成成功！');
                    console.log('✅ 中心主题:', result.text);
                    console.log('✅ 一级分支数:', result.children?.length || 0);
                    return result;
                } else if (result === null) {
                    console.warn('⚠️ [生成] API返回null，JSON解析失败，降级到本地');
                } else {
                    console.warn('⚠️ [生成] API返回格式不对，降级到本地');
                    console.warn('返回数据:', JSON.stringify(result).substring(0, 200));
                }
            } catch (e) {
                console.error('❌ [生成] API调用异常:', e.message);
                console.error('异常堆栈:', e.stack?.substring(0, 300));
            }
        } else {
            console.log('⚠️ [生成] API未启用，使用本地生成');
        }
        
        console.log('📝 [生成] 使用本地生成器...');
        const localResult = this.localGenerateFromTopic(topic, template);
        console.log('✅ [生成] 本地生成完成，一级分支数:', localResult.children?.length || 0);
        return localResult;
    }
    
    async analyzeText(text, options = {}) {
        const { analysisType = 'business' } = options;
        
        console.log('\n📊 [分析] ========== 开始本地分析 ==========');
        console.log('📌 分析类型:', this.getAnalysisTypeName(analysisType));
        console.log('📌 文本长度:', text.length, '字符');
        console.log('📝 注意：分析面板仅使用本地分析，不调用 API');
        
        // 分析面板只做本地分析，不接API
        const result = this.textAnalyzer.analyze(text, options);
        
        console.log('✅ [分析] 本地分析完成');
        console.log('✅ 一级分支数:', result.children?.length || 0);
        return result;
    }
    
    getAnalysisTypeName(type) {
        const names = {
            'business': '业务架构分析',
            'technical': '技术架构分析',
            'system': '系统架构分析',
            'data': '数据架构分析',
            'organization': '组织架构分析'
        };
        return names[type] || '分析';
    }
    
    async expandNode(nodeText, context = '', depth = 2) {
        if (this.apiEnabled) {
            try {
                const prompt = `你是思维导图扩展专家。请为以下节点生成${depth}层深的子节点展开。

【节点主题】"${nodeText}"

【扩展要求】
1. 一级展开：提取该主题的3-5个核心分类或维度
2. 二级展开：每个分类下2-3个具体内容点，逐层深化
3. 内容特点：每个节点5-25字，是具体的概念、方法、或要点

【质量标准】
- 逻辑清晰：各分支相互补充，不重复
- 系统完整：覆盖该主题的主要方面
- 可操作性：内容具体、有参考价值

返回JSON格式：{"children":[{"text":"分类1","children":[{"text":"详情1-1"},{"text":"详情1-2"}]},{"text":"分类2","children":[...]}]}
只返回JSON，不要其他文本。`;
                const result = await this.callAPI(prompt);
                if (result && result.children) return result;
            } catch (e) {
                console.warn('API扩展失败:', e.message);
            }
        }
        return this.localExpandNode(nodeText);
    }
    
    localGenerateFromTopic(topic, template) {
        const templates = {
            general: [
                { 
                    name: '概念定义', 
                    children: [
                        { text: '基本定义与解释', children: ['核心含义', '学术解释', '通俗理解'] },
                        { text: '核心原理与机制', children: ['运作原理', '内在逻辑', '相互关系'] },
                        { text: '主要特征与属性', children: ['显著特征', '关键属性', '典型标志'] }
                    ]
                },
                { 
                    name: '价值意义', 
                    children: [
                        { text: '解决什么问题', children: ['核心问题', '痛点分析', '需求场景'] },
                        { text: '带来什么好处', children: ['直接收益', '间接价值', '长期影响'] },
                        { text: '应用场景举例', children: ['典型案例', '成功经验', '应用效果'] }
                    ]
                },
                { 
                    name: '实施方法', 
                    children: [
                        { text: '准备工作要点', children: ['资源准备', '前置条件', '准备检查'] },
                        { text: '具体操作步骤', children: ['第一步骤', '第二步骤', '第三步骤'] },
                        { text: '关键成功因素', children: ['关键要素', '注意事项', '最佳实践'] }
                    ]
                },
                { 
                    name: '深入拓展', 
                    children: [
                        { text: '高级技巧方法', children: ['进阶技能', '优化策略', '创新应用'] },
                        { text: '最佳实践案例', children: ['行业标准', '成功案例', '经验总结'] },
                        { text: '发展趋势展望', children: ['发展方向', '未来机遇', '创新方向'] }
                    ]
                }
            ],
            product: [
                { 
                    name: '市场洞察', 
                    children: [
                        { text: '目标市场规模', children: ['市场总量', '增长率', '市场分布'] },
                        { text: '用户需求痛点', children: ['用户问题', '痛点优先级', '未被满足的需求'] },
                        { text: '竞争对手分析', children: ['主要竞争者', '竞争优劣', '市场空隙'] }
                    ]
                },
                { 
                    name: '产品定位', 
                    children: [
                        { text: '核心价值主张', children: ['独特价值', '价值传递', '用户获得'] },
                        { text: '目标用户画像', children: ['用户特征', '用户需求', '用户行为'] },
                        { text: '差异化优势', children: ['竞争优势', '差异化点', '防御壁垒'] }
                    ]
                },
                { 
                    name: '功能规划', 
                    children: [
                        { text: '核心功能模块', children: ['基础功能', '核心功能', '高级功能'] },
                        { text: 'MVP最小可行产品', children: ['最小功能集', '快速验证', '用户反馈'] },
                        { text: '用户体验设计', children: ['界面设计', '交互流程', '易用性'] }
                    ]
                },
                { 
                    name: '落地执行', 
                    children: [
                        { text: '技术实现方案', children: ['技术选型', '架构设计', '实现难度'] },
                        { text: '开发阶段规划', children: ['项目周期', '里程碑', '交付计划'] },
                        { text: '风险应对预案', children: ['技术风险', '市场风险', '应对策略'] }
                    ]
                }
            ]
        };
        
        const structure = templates[template] || templates.general;
        
        return {
            text: topic,
            children: structure.map(section => ({
                text: section.name,
                children: section.children.map(child => 
                    typeof child === 'string' 
                        ? { text: child, children: [] }
                        : {
                            text: child.text,
                            children: (child.children || []).map(subitem => ({ text: subitem, children: [] }))
                        }
                )
            }))
        };
    }
    
    localExpandNode(nodeText) {
        const patterns = {
            '分析|研究|调研': ['现状数据收集', '问题识别诊断', '原因深入分析', '改进方向建议'],
            '规划|计划|设计': ['目标设定分解', '实施路径规划', '资源需求估算', '时间节点安排'],
            '实施|执行|推进': ['前期准备工作', '具体执行步骤', '过程监控要点', '问题应对预案'],
            '评估|总结|复盘': ['成果量化评价', '经验提炼总结', '不足改进方向', '后续行动计划'],
            '优化|改进|提升': ['现状问题诊断', '优化方案设计', '实施效果预期', '持续改进机制']
        };
        
        for (const [pattern, items] of Object.entries(patterns)) {
            if (new RegExp(pattern).test(nodeText)) {
                return { children: items.map(item => ({ text: item, children: [] })) };
            }
        }
        
        return {
            children: [
                { text: `${nodeText}的核心要点`, children: [] },
                { text: `${nodeText}的实现方法`, children: [] },
                { text: `${nodeText}的关键因素`, children: [] },
                { text: `${nodeText}的注意事项`, children: [] }
            ]
        };
    }
    
    async callAPI(prompt) {
        if (!this.apiEnabled) throw new Error('API未配置');
        
        const fullUrl = this.getFullUrl();
        if (!fullUrl) throw new Error('API主机地址未配置');
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);
        
        try {
            console.log('🔌 [AI] 正在调用 API:', { url: fullUrl, model: this.model });
            
            const response = await fetch(fullUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify({
                    model: this.model,
                    messages: [
                        { role: 'system', content: '你是思维导图生成专家。返回严格的JSON格式，每个节点是完整短语（5-25字）。' },
                        { role: 'user', content: prompt }
                    ],
                    max_tokens: 4000,
                    temperature: 0.7
                }),
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                console.error('❌ [AI] API 返回错误:', response.status, response.statusText);
                throw new Error(`API错误: ${response.status}`);
            }
            
            const data = await response.json();
            const content = data.choices?.[0]?.message?.content;
            if (!content) {
                console.error('❌ [AI] API 返回为空');
                throw new Error('API返回为空');
            }
            
            console.log('✅ [AI] API 调用成功，开始解析响应');
            let result = this.parseJSON(content);
            console.log('✅ [AI] 解析完成，返回结果:', result);
            
            // 如果结果是字符串，尝试再次解析
            if (typeof result === 'string') {
                console.warn('⚠️ [AI] 结果是字符串，尝试再次解析');
                result = this.parseJSON(result);
            }
            
            // 如果仍然无效，抛出错误
            if (!result) {
                console.error('❌ [AI] JSON解析失败，无法获取有效数据');
                throw new Error('JSON解析失败');
            }
            
            console.log('🎯 [AI] 最终结果类型:', typeof result, '是否有text:', !!result.text, '是否有children:', !!result.children);
            return result;
        } catch (error) {
            clearTimeout(timeoutId);
            console.error('❌ [AI] 调用失败:', error.message);
            throw error;
        }
    }
    
    parseJSON(content) {
        try {
            const parsed = JSON.parse(content);
            console.log('📦 [JSON] 直接解析成功:', typeof parsed, Object.keys(parsed || {}).length, '个字段');
            return parsed;
        } catch (e) {
            console.warn('⚠️ [JSON] 直接解析失败:', e.message);
            console.log('📝 [JSON] 原始响应长度:', content.length, '字符');
            console.log('📝 [JSON] 原始响应前500字:', content.substring(0, 500));
            
            const match = content.match(/\{[\s\S]*\}/);
            if (match) {
                try {
                    const parsed = JSON.parse(match[0]);
                    console.log('📦 [JSON] 提取后解析成功:', Object.keys(parsed || {}).length, '个字段');
                    return parsed;
                } catch (e2) {
                    console.error('❌ [JSON] 提取后仍然失败:', e2.message);
                }
            } else {
                console.error('❌ [JSON] 找不到JSON对象');
            }
        }
        console.error('❌ [JSON] 解析最终失败，返回null');
        return null;
    }
    
    buildTopicPrompt(topic, template) {
        const templates = {
            general: {
                name: '通用框架',
                structure: `
【一级分支示例】：
• 概念定义 - 什么是${topic}
  - 基本定义、核心原理、主要特征
• 价值意义 - 为什么需要${topic}
  - 解决问题、带来好处、应用场景
• 实施方法 - 怎样应用${topic}
  - 准备工作、操作步骤、成功因素
• 深入拓展 - ${topic}的进阶内容
  - 高级技巧、最佳实践、发展趋势`,
                guidance: '按照【定义→原理→特征→应用】逻辑展开，层层深入'
            },
            product: {
                name: '产品规划',
                structure: `
【一级分支示例】：
• 市场分析 - ${topic}的市场现状
  - 市场规模、用户需求、竞争分析
• 产品定位 - ${topic}的核心价值
  - 价值主张、目标用户、差异优势
• 功能设计 - ${topic}的功能规划
  - 核心功能、MVP设计、用户体验
• 商业模式 - ${topic}的盈利方案
  - 收入模式、成本结构、财务预测
• 实施计划 - ${topic}的落地执行
  - 技术方案、开发计划、风险应对`,
                guidance: '按照【市场→定位→功能→模式→执行】顺序组织，具有商业价值'
            },
            project: {
                name: '项目管理',
                structure: `
【一级分支示例】：
• 项目定义 - ${topic}的项目背景
  - 背景目标、范围界定、成功标准
• 规划阶段 - ${topic}的项目规划
  - 工作分解、进度计划、资源分配
• 执行阶段 - ${topic}的项目执行
  - 任务执行、进度跟踪、问题管理
• 监控阶段 - ${topic}的项目监控
  - 进度监控、质量控制、风险管理
• 收尾总结 - ${topic}的项目总结
  - 成果验收、经验总结、知识沉淀`,
                guidance: '按照【定义→规划→执行→监控→收尾】项目管理框架展开'
            },
            business: {
                name: '业务分析',
                structure: `
【一级分支示例】：
• 环境分析 - ${topic}的外部环境
  - 宏观环境、行业趋势、竞争格局
• 战略规划 - ${topic}的战略方向
  - 愿景目标、核心优势、发展策略
• 运营管理 - ${topic}的运营体系
  - 组织设计、流程优化、团队建设
• 财务规划 - ${topic}的财务方案
  - 收入模式、成本管理、盈利预测
• 风险管理 - ${topic}的风险应对
  - 风险识别、风险评估、应对策略`,
                guidance: '按照【分析→战略→运营→财务→风险】商业系统思维组织'
            },
            research: {
                name: '研究框架',
                structure: `
【一级分支示例】：
• 研究背景 - ${topic}的研究意义
  - 问题提出、文献综述、理论基础
• 研究设计 - ${topic}的研究方法
  - 研究目标、方法选择、数据来源
• 研究发现 - ${topic}的研究成果
  - 主要发现、数据分析、结论总结
• 应用价值 - ${topic}的应用意义
  - 理论意义、实践价值、创新贡献
• 未来方向 - ${topic}的研究展望
  - 存在问题、研究方向、后续计划`,
                guidance: '按照【背景→设计→发现→应用→展望】学术研究逻辑展开'
            }
        };

        const config = templates[template] || templates.general;

        return `你是思维导图生成专家和${config.name}顾问。请为"${topic}"生成专业、详尽的思维导图。

【生成框架】
${config.structure}

【核心要求】
1. 严格按照上述结构生成，一级分支必须是【】内的类别
2. 每个一级分支下有3-4个二级分支
3. 重要的二级分支下还要有3-4个三级细节
4. 确保生成的是【结构化的多层思维导图】

【内容质量】
- 每个节点5-25字，是完整的概念短语，不只是单词
- 逻辑清晰，各分支相互补充，不重复
- 体现${config.name}的专业性和系统性
- 包含具体的、可操作的内容

【JSON输出格式】（必须严格遵守）
{
  "text": "${topic}",
  "children": [
    {
      "text": "一级分支名称",
      "children": [
        {
          "text": "二级分支内容",
          "children": [
            {"text": "三级细节"},
            {"text": "三级细节"}
          ]
        },
        {
          "text": "二级分支内容",
          "children": [...]
        }
      ]
    }
  ]
}

【绝对要求】
✅ 必须返回有效的JSON格式
✅ 至少包含4-5个一级分支
✅ 至少达到3层深度（中心→一级→二级）
✅ 重要分支应展开到第4层
✅ 只返回JSON，不要其他任何文本`;
    }
    
    buildAnalyzePrompt(text, analysisType = 'business') {
        const preview = text.length > 2000 ? text.substring(0, 2000) + '...' : text;
        
        const analysisConfigs = {
            'business': {
                name: '业务架构分析',
                focus: ['业务流程', '价值链', '业务能力', '组织结构', '商业模式'],
                prompt: `请从业务角度进行深度分析，重点关注：
• 核心业务流程和价值链分解
• 商业模式设计和收入流
• 目标客户和市场定位细节
• 竞争优势和差异化点
• 关键风险、机遇和增长空间`
            },
            'technical': {
                name: '技术架构分析',
                focus: ['技术栈', '系统组件', '接口设计', '技术选型', '性能考虑'],
                prompt: `请从技术架构角度进行深度分析，重点关注：
• 采用的技术栈、框架和工具链
• 系统核心组件、模块划分和职责
• 各服务间的接口、集成和通信方式
• 技术选型的优缺点和权衡
• 性能指标、可扩展性和可维护性`
            },
            'system': {
                name: '系统架构分析',
                focus: ['系统模块', '数据流', '服务关系', '部署结构', '集成方案'],
                prompt: `请从系统架构角度进行深度分析，重点关注：
• 系统的模块划分、职责和边界定义
• 各模块和组件间的数据流、交互流程
• 服务间的依赖关系、耦合度和通信
• 系统的部署拓扑、运维架构和高可用设计
• 与其他系统的集成接口和数据交换`
            },
            'data': {
                name: '数据架构分析',
                focus: ['数据模型', '数据流', '存储方案', '数据处理', '数据安全'],
                prompt: `请从数据架构角度进行深度分析，重点关注：
• 核心数据实体、模型、关系和业务含义
• 数据的来源、收集、流转、存储和使用流程
• 数据存储方案选择、分库分表和优化
• 数据处理、加工、分析和挖掘方法
• 数据安全、隐私、备份和容灾设计`
            },
            'organization': {
                name: '组织架构分析',
                focus: ['部门结构', '角色职责', '协作关系', '决策流程', '沟通机制'],
                prompt: `请从组织结构角度进行深度分析，重点关注：
• 组织的部门结构、层级、规模和功能
• 各角色的职责定义、权限划分和晋升路径
• 部门间和团队间的协作关系、矩阵管理
• 决策流程、权力分配和治理机制
• 信息流动、沟通机制和文化建设`
            }
        };
        
        const config = analysisConfigs[analysisType] || analysisConfigs['business'];
        
        return `你是企业架构和战略分析专家。请对下面的内容进行深度${config.name}分析。

【分析内容】
"""
${preview}
"""

【分析视角】
${config.prompt}

【输出结构】
严格按照以下JSON格式输出，包含中心主题、多层级分支、关键发现和建议：

{
  "text": "分析主题（核心对象）",
  "children": [
    {
      "text": "一级维度1（5-15字说明主要方向）",
      "children": [
        {"text": "二级分析点1（对该维度的具体分析，5-20字）"},
        {"text": "二级分析点2（对该维度的具体分析，5-20字）"},
        {"text": "二级分析点3（更深入的细节或子维度）"}
      ]
    },
    {
      "text": "一级维度2（5-15字说明主要方向）",
      "children": [
        {"text": "二级分析点1（对该维度的具体分析，5-20字）"},
        {"text": "二级分析点2（对该维度的具体分析，5-20字）"}
      ]
    },
    {
      "text": "关键发现与洞察",
      "children": [
        {"text": "重要发现1：[具体的、有价值的、可交付的洞察]"},
        {"text": "重要发现2：[指出的问题、风险或机遇]"},
        {"text": "重要发现3：[战略性建议或优化方向]"}
      ]
    },
    {
      "text": "建议与改进方案",
      "children": [
        {"text": "建议1：[具体可行的改进方案，包含优先级和预期效果]"},
        {"text": "建议2：[具体可行的改进方案，包含优先级和预期效果]"},
        {"text": "建议3：[具体可行的改进方案，包含优先级和预期效果]"}
      ]
    }
  ]
}

【质量要求】
1. 分析必须具有深度和洞察力，不是简单重复输入内容
2. 关键发现必须是原创的、有价值的、可操作的建议
3. 每个节点应为完整的短语或观点，而不是单个词语
4. 确保分支之间的逻辑关系清晰、层级分明、相互补充
5. 提供具有战略价值的分析和可实施的建议

【重点提醒】
- 不要输出思维导图文本格式，只输出JSON
- 确保JSON格式严格有效
- 关键发现和建议部分必须包含在输出中
- 每个分析维度应有3-5个二级分析点
- 只返回JSON，不要任何其他解释文本`;
    }
}
// ==================== 渲染器 ====================
class Renderer {
    constructor(nodesContainer, svgContainer) {
        this.nodesContainer = nodesContainer;
        this.svgContainer = svgContainer;
        this.layout = new Layout();
        this.theme = null;
        this.nodeElements = new Map();
    }
    
    setTheme(theme) {
        this.theme = theme;
    }
    
    render(root, canvasHeight) {
        this.layout.calculate(root, canvasHeight);
        this.clear();
        this.renderConnections(root);
        this.renderNodes(root, 0);
    }
    
    clear() {
        this.nodesContainer.innerHTML = '';
        this.svgContainer.innerHTML = '';
        this.nodeElements.clear();
    }
    
    renderNodes(node, depth) {
        const element = this.renderNode(node, depth);
        this.nodeElements.set(node.id, element);
        
        if (node.expanded) {
            for (const child of node.children) {
                this.renderNodes(child, depth + 1);
            }
        }
    }
    
    renderNode(node, depth) {
        const element = document.createElement('div');
        element.className = 'mind-node';
        element.id = `node-${node.id}`;
        element.dataset.nodeId = node.id;
        element.dataset.depth = depth;
        
        if (depth === 0) {
            element.classList.add('root');
        } else if (depth <= 4) {
            element.classList.add(`level-${depth}`);
        }
        
        if (node.style.shape && node.style.shape !== 'rounded') {
            element.classList.add(`shape-${node.style.shape}`);
        }
        
        if (node.selected) {
            element.classList.add('selected');
        }
        
        element.style.left = `${node.x}px`;
        element.style.top = `${node.y}px`;
        
        this.applyNodeStyle(element, node, depth);
        element.innerHTML = this.buildNodeHTML(node);
        
        this.nodesContainer.appendChild(element);
        node.element = element;
        
        const rect = element.getBoundingClientRect();
        node.width = rect.width;
        node.height = rect.height;
        
        return element;
    }
    
    buildNodeHTML(node) {
        let html = '<div class="node-content">';
        
        if (node.icon) {
            html += `<span class="node-icon">${node.icon}</span>`;
        }
        
        html += `<span class="node-text">${this.escapeHtml(node.text)}</span>`;
        html += '</div>';
        
        if (node.children.length > 0) {
            const icon = node.expanded ? '−' : '+';
            const count = node.getTotalChildCount();
            html += `<button class="node-expand-btn" title="${count}个子节点">${icon}</button>`;
        }
        
        const badges = [];
        if (node.note) badges.push('📝');
        if (node.link) badges.push('🔗');
        
        if (badges.length > 0) {
            html += '<div class="node-badges">';
            for (const badge of badges) {
                html += `<span class="node-badge">${badge}</span>`;
            }
            html += '</div>';
        }
        
        return html;
    }
    
    applyNodeStyle(element, node, depth) {
        const themeColor = this.theme ? this.theme.colors[Math.min(depth, this.theme.colors.length - 1)] : null;
        
        if (node.style.backgroundColor) {
            element.style.backgroundColor = node.style.backgroundColor;
        } else if (themeColor) {
            element.style.backgroundColor = themeColor;
        }
        
        if (node.style.textColor) {
            element.style.color = node.style.textColor;
        }
        
        if (node.style.fontSize) {
            element.style.fontSize = `${node.style.fontSize}px`;
        }
    }
    
    renderConnections(node) {
        if (!node.expanded) return;
        
        for (const child of node.children) {
            this.renderConnection(node, child);
            this.renderConnections(child);
        }
    }
    
    renderConnection(parent, child) {
        const path = this.layout.getConnectionPath(parent, child);
        const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        pathElement.classList.add('connection-path');
        pathElement.setAttribute('d', path);
        
        const color = this.theme?.lineColor || '#999';
        pathElement.style.stroke = color;
        
        this.svgContainer.appendChild(pathElement);
    }
    
    updateSelection(node, selected, isMulti = false) {
        const element = this.nodeElements.get(node.id);
        if (!element) return;
        
        element.classList.remove('selected', 'multi-selected');
        if (selected) {
            element.classList.add(isMulti ? 'multi-selected' : 'selected');
        }
    }
    
    startEdit(node) {
        const element = this.nodeElements.get(node.id);
        if (!element) return null;
        
        node.editing = true;
        const textSpan = element.querySelector('.node-text');
        if (!textSpan) return null;
        
        const currentText = node.text;
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'node-input';
        input.value = currentText;
        input.style.width = Math.max(60, currentText.length * 14) + 'px';
        
        textSpan.innerHTML = '';
        textSpan.appendChild(input);
        
        input.focus();
        input.select();
        
        input.addEventListener('input', () => {
            input.style.width = Math.max(60, input.value.length * 14) + 'px';
        });
        
        return input;
    }
    
    endEdit(node, save = true) {
        const element = this.nodeElements.get(node.id);
        if (!element) return;
        
        const input = element.querySelector('.node-input');
        if (input && save) {
            const newText = input.value.trim();
            if (newText) {
                node.text = newText;
            }
        }
        
        node.editing = false;
        const textSpan = element.querySelector('.node-text');
        if (textSpan) {
            textSpan.innerHTML = this.escapeHtml(node.text);
        }
    }
    
    setDragging(node, dragging) {
        const element = this.nodeElements.get(node.id);
        if (element) {
            element.classList.toggle('dragging', dragging);
        }
    }
    
    setDropTarget(node, isTarget) {
        const element = this.nodeElements.get(node.id);
        if (element) {
            element.classList.toggle('drop-target', isTarget);
        }
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// ==================== 导出功能 ====================
class Exporter {
    constructor(mindMap) {
        this.mindMap = mindMap;
    }
    
    async toPNG(filename = 'mindmap') {
        const canvas = await this.renderToCanvas(2);
        const dataUrl = canvas.toDataURL('image/png');
        this.download(dataUrl, `${filename}.png`);
    }
    
    async toJPG(filename = 'mindmap') {
        const canvas = await this.renderToCanvas(2);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
        this.download(dataUrl, `${filename}.jpg`);
    }
    
    toJSON(filename = 'mindmap') {
        const data = {
            version: '1.0',
            exportTime: new Date().toISOString(),
            root: this.mindMap.root.toJSON()
        };
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        this.download(url, `${filename}.json`);
        URL.revokeObjectURL(url);
    }
    
    toMarkdown(filename = 'mindmap') {
        const md = this.mindMap.root.toMarkdown(0);
        const blob = new Blob([md], { type: 'text/markdown;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        this.download(url, `${filename}.md`);
        URL.revokeObjectURL(url);
    }
    
    toText(filename = 'mindmap') {
        const text = this.mindMap.root.toText(0);
        const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        this.download(url, `${filename}.txt`);
        URL.revokeObjectURL(url);
    }
    
    async renderToCanvas(scale = 2) {
        const root = this.mindMap.root;
        const bounds = this.calculateBounds(root);
        const padding = 50;
        
        const canvas = document.createElement('canvas');
        canvas.width = (bounds.width + padding * 2) * scale;
        canvas.height = (bounds.height + padding * 2) * scale;
        
        const ctx = canvas.getContext('2d');
        ctx.scale(scale, scale);
        
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width / scale, canvas.height / scale);
        
        const offsetX = -bounds.minX + padding;
        const offsetY = -bounds.minY + padding;
        
        this.drawConnections(ctx, root, offsetX, offsetY);
        this.drawNodes(ctx, root, offsetX, offsetY, 0);
        
        return canvas;
    }
    
    calculateBounds(root) {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        const traverse = (node) => {
            const w = node.width || 120;
            const h = node.height || 40;
            minX = Math.min(minX, node.x);
            minY = Math.min(minY, node.y);
            maxX = Math.max(maxX, node.x + w);
            maxY = Math.max(maxY, node.y + h);
            if (node.expanded) node.children.forEach(traverse);
        };
        
        traverse(root);
        return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
    }
    
    drawConnections(ctx, node, offsetX, offsetY) {
        if (!node.expanded) return;
        
        for (const child of node.children) {
            const pw = node.width || 120, ph = node.height || 40;
            const ch = child.height || 40;
            
            const startX = node.x + pw + offsetX;
            const startY = node.y + ph / 2 + offsetY;
            const endX = child.x + offsetX;
            const endY = child.y + ch / 2 + offsetY;
            const cpX = (startX + endX) / 2;
            
            ctx.beginPath();
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            ctx.moveTo(startX, startY);
            ctx.bezierCurveTo(cpX, startY, cpX, endY, endX, endY);
            ctx.stroke();
            
            this.drawConnections(ctx, child, offsetX, offsetY);
        }
    }
    
    drawNodes(ctx, node, offsetX, offsetY, depth) {
        const x = node.x + offsetX;
        const y = node.y + offsetY;
        const w = node.width || 120;
        const h = node.height || 40;
        const r = 8;
        
        const colors = this.mindMap.themes.getCurrentTheme().colors;
        const bgColor = node.style.backgroundColor || colors[Math.min(depth, colors.length - 1)];
        const textColor = node.style.textColor || '#FFFFFF';
        
        ctx.fillStyle = bgColor;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = textColor;
        ctx.font = `${node.style.fontSize || 14}px -apple-system, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const text = (node.icon ? node.icon + ' ' : '') + node.text;
        ctx.fillText(text, x + w / 2, y + h / 2, w - 16);
        
        if (node.expanded) {
            node.children.forEach(child => this.drawNodes(ctx, child, offsetX, offsetY, depth + 1));
        }
    }
    
    download(url, filename) {
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
}

// ==================== 导入功能 ====================
class Importer {
    constructor(mindMap) {
        this.mindMap = mindMap;
    }
    
    async fromFile(file) {
        const ext = file.name.split('.').pop().toLowerCase();
        const content = await this.readFile(file);
        
        switch (ext) {
            case 'json':
                return this.fromJSON(content);
            case 'md':
            case 'txt':
                return this.fromText(content);
            default:
                throw new Error('不支持的文件格式');
        }
    }
    
    readFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = () => reject(new Error('文件读取失败'));
            reader.readAsText(file);
        });
    }
    
    fromJSON(content) {
        try {
            const data = JSON.parse(content);
            return Node.fromJSON(data.root || data);
        } catch (e) {
            throw new Error('JSON格式错误');
        }
    }
    
    fromText(content) {
        const analyzer = new TextAnalyzer();
        const result = analyzer.analyze(content);
        return Node.fromJSON(result);
    }
}

// ==================== MindMap 核心类 ====================
class MindMap {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.nodesContainer = document.getElementById('nodes-layer');
        this.svgContainer = document.getElementById('connections-svg');
        
        this.root = new Node({ text: '中心主题' });
        
        this.scale = 1;
        this.panX = 0;
        this.panY = 0;
        
        this.selectedNodes = new Set();
        this.clipboard = null;
        
        this.themes = new Themes();
        this.renderer = new Renderer(this.nodesContainer, this.svgContainer);
        this.history = new History();
        this.aiService = new AIService();
        this.exporter = new Exporter(this);
        this.importer = new Importer(this);
        
        this.isDragging = false;
        this.dragNode = null;
        this.isPanning = false;
        
        this.setTheme('business');
        this.history.onChange = this.onHistoryChange.bind(this);
        
        this.init();
    }
    
    init() {
        this.loadAPIConfig();
        this.bindEvents();
        this.centerView();
        this.render();
        this.saveState('初始化');
        this.startAutoSave();
    }
    
    loadAPIConfig() {
        const saved = localStorage.getItem('mindmap_api_config');
        if (saved) {
            try {
                this.aiService.configure(JSON.parse(saved));
            } catch (e) {}
        }
    }
    
    // ========== 渲染 ==========
    render() {
        const rect = this.container.getBoundingClientRect();
        this.renderer.setTheme(this.themes.getCurrentTheme());
        this.renderer.render(this.root, rect.height);
        this.updateTransform();
        this.updateOutline();
        this.updateMinimap();
    }
    
    updateTransform() {
        const transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.scale})`;
        this.nodesContainer.style.transform = transform;
        this.svgContainer.style.transform = transform;
        document.getElementById('zoom-level').textContent = Math.round(this.scale * 100) + '%';
    }
    
    centerView() {
        const rect = this.container.getBoundingClientRect();
        this.panX = rect.width / 2 - 400;
        this.panY = rect.height / 2 - 50;
        this.updateTransform();
    }
    
    // ========== 节点操作 ==========
    addChild(parentId, text = '新节点') {
        const parent = this.findNode(parentId);
        if (!parent) return null;
        
        const child = parent.addChild({ text });
        parent.expanded = true;
        
        this.render();
        this.clearSelection();
        this.selectNode(child.id);
        this.saveState('添加子节点');
        
        setTimeout(() => this.startEdit(child), 100);
        return child;
    }
    
    addSibling(nodeId, text = '新节点') {
        const node = this.findNode(nodeId);
        if (!node || node.isRoot()) return null;
        
        const parent = this.findNode(node.parentId);
        if (!parent) return null;
        
        const index = parent.children.findIndex(c => c.id === node.id);
        const sibling = new Node({ text });
        sibling.parentId = parent.id;
        parent.children.splice(index + 1, 0, sibling);
        
        this.render();
        this.clearSelection();
        this.selectNode(sibling.id);
        this.saveState('添加同级节点');
        
        setTimeout(() => this.startEdit(sibling), 100);
        return sibling;
    }
    
    deleteSelectedNodes() {
        const nodes = this.getSelectedNodes();
        if (nodes.length === 0) {
            this.showToast('请先选择要删除的节点', 'warning');
            return;
        }
        
        const deletable = nodes.filter(n => !n.isRoot());
        if (deletable.length === 0) {
            this.showToast('根节点不能删除', 'warning');
            return;
        }
        
        for (const node of deletable) {
            const parent = this.findNode(node.parentId);
            if (parent) parent.removeChild(node.id);
        }
        
        this.clearSelection();
        this.render();
        this.saveState('删除节点');
        this.showToast(`已删除 ${deletable.length} 个节点`, 'success');
    }
    
    findNode(nodeId, startNode = this.root) {
        if (startNode.id === nodeId) return startNode;
        for (const child of startNode.children) {
            const found = this.findNode(nodeId, child);
            if (found) return found;
        }
        return null;
    }
    
    traverseNodes(callback, node = this.root) {
        callback(node);
        for (const child of node.children) {
            this.traverseNodes(callback, child);
        }
    }
    
    // ========== 编辑 ==========
    startEdit(node) {
        const input = this.renderer.startEdit(node);
        if (!input) return;
        
        const finishEdit = (save) => {
            const oldText = node.text;
            this.renderer.endEdit(node, save);
            if (save && node.text !== oldText) {
                this.saveState('编辑节点');
            }
        };
        
        input.addEventListener('blur', () => finishEdit(true));
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
            if (e.key === 'Escape') { finishEdit(false); input.blur(); }
        });
    }
    
    // ========== 选择 ==========
    selectNode(nodeId, addToSelection = false) {
        const node = this.findNode(nodeId);
        if (!node) return;
        
        if (!addToSelection) this.clearSelection();
        
        node.selected = true;
        this.selectedNodes.add(nodeId);
        
        const isMulti = this.selectedNodes.size > 1;
        this.renderer.updateSelection(node, true, isMulti);
        
        if (isMulti) {
            for (const id of this.selectedNodes) {
                const n = this.findNode(id);
                if (n) this.renderer.updateSelection(n, true, true);
            }
        }
        
        this.updateStylePanel(node);
    }
    
    clearSelection() {
        for (const id of this.selectedNodes) {
            const node = this.findNode(id);
            if (node) {
                node.selected = false;
                this.renderer.updateSelection(node, false);
            }
        }
        this.selectedNodes.clear();
    }
    
    getSelectedNodes() {
        return Array.from(this.selectedNodes).map(id => this.findNode(id)).filter(Boolean);
    }
    
    getFirstSelected() {
        if (this.selectedNodes.size === 0) return null;
        return this.findNode(this.selectedNodes.values().next().value);
    }
    
    // ========== 复制粘贴 ==========
    copyNodes() {
        const nodes = this.getSelectedNodes();
        if (nodes.length === 0) return;
        this.clipboard = nodes.map(n => n.clone());
        this.showToast(`已复制 ${nodes.length} 个节点`, 'success');
    }
    
    pasteNodes() {
        if (!this.clipboard || this.clipboard.length === 0) {
            this.showToast('剪贴板为空', 'warning');
            return;
        }
        
        const target = this.getFirstSelected() || this.root;
        for (const node of this.clipboard) {
            target.addChild(node.clone());
        }
        target.expanded = true;
        
        this.render();
        this.saveState('粘贴节点');
        this.showToast(`已粘贴 ${this.clipboard.length} 个节点`, 'success');
    }
    
    // ========== 缩放 ==========
    zoomIn() {
        this.scale = Math.min(3, this.scale + 0.1);
        this.updateTransform();
        this.showZoomHint();
    }
    
    zoomOut() {
        this.scale = Math.max(0.2, this.scale - 0.1);
        this.updateTransform();
        this.showZoomHint();
    }
    
    zoomToFit() {
        this.scale = 1;
        this.centerView();
        this.showZoomHint();
    }
    
    showZoomHint() {
        const hint = document.getElementById('zoom-hint');
        hint.textContent = Math.round(this.scale * 100) + '%';
        hint.classList.add('visible');
        clearTimeout(this.zoomHintTimeout);
        this.zoomHintTimeout = setTimeout(() => hint.classList.remove('visible'), 800);
    }
    
    // ========== 历史 ==========
    saveState(description) {
        this.history.push(this.root.toJSON(), description);
    }
    
    undo() {
        const state = this.history.undo(this.root.toJSON());
        if (state) {
            this.root = Node.fromJSON(state);
            this.clearSelection();
            this.render();
            this.showToast('已撤销', 'info');
        }
    }
    
    redo() {
        const state = this.history.redo(this.root.toJSON());
        if (state) {
            this.root = Node.fromJSON(state);
            this.clearSelection();
            this.render();
            this.showToast('已重做', 'info');
        }
    }
    
    onHistoryChange(state) {
        document.getElementById('btn-undo').disabled = !state.canUndo;
        document.getElementById('btn-redo').disabled = !state.canRedo;
    }
    
    // ========== 主题 ==========
    setTheme(name) {
        this.themes.setTheme(name);
        this.renderer.setTheme(this.themes.getCurrentTheme());
    }
    
    // ========== AI功能 ==========
    async aiGenerate(input, mode, template, analysisType = 'business') {
        this.showLoading('AI正在生成...');
        
        try {
            let result;
            if (mode === 'topic') {
                result = await this.aiService.generateFromTopic(input, { template });
            } else {
                result = await this.aiService.analyzeText(input, { analysisType });
            }
            
            console.log('📊 [生成] 最终结果:', result);
            console.log('📊 [生成] 结果类型:', typeof result);
            console.log('📊 [生成] 是否有text:', result?.text);
            console.log('📊 [生成] 子节点数:', result?.children?.length || 0);
            
            if (result && result.text) {
                console.log('✅ [生成] 创建节点树，中心主题:', result.text);
                this.root = Node.fromJSON(result);
                console.log('✅ [生成] 节点创建完成，根节点子节点数:', this.root.children.length);
                this.render();
                this.centerView();
                this.saveState('AI生成');
                this.showToast('生成成功！', 'success');
            } else {
                throw new Error('生成结果为空或缺少text字段');
            }
        } catch (error) {
            console.error('❌ [生成] 错误详情:', error);
            this.showToast('生成失败: ' + error.message, 'error');
        } finally {
            this.hideLoading();
        }
    }
    
    async aiExpandNode(node) {
        this.showLoading('AI正在扩展...');
        
        try {
            const result = await this.aiService.expandNode(node.text);
            if (result && result.children) {
                for (const childData of result.children) {
                    const child = Node.fromJSON(childData);
                    child.parentId = node.id;
                    node.children.push(child);
                }
                node.expanded = true;
                this.render();
                this.saveState('AI扩展节点');
                this.showToast('扩展完成！', 'success');
            }
        } catch (error) {
            this.showToast('扩展失败: ' + error.message, 'error');
        } finally {
            this.hideLoading();
        }
    }
    
    // ========== 导入导出 ==========
    async loadFromFile(file) {
        try {
            this.showLoading('正在加载...');
            const root = await this.importer.fromFile(file);
            this.root = root;
            this.render();
            this.centerView();
            this.history.clear();
            this.saveState('导入文件');
            this.showToast('加载成功！', 'success');
        } catch (error) {
            this.showToast('加载失败: ' + error.message, 'error');
        } finally {
            this.hideLoading();
        }
    }
    
    exportAs(format) {
        try {
            switch (format) {
                case 'png': this.exporter.toPNG(); break;
                case 'jpg': this.exporter.toJPG(); break;
                case 'json': this.exporter.toJSON(); break;
                case 'markdown': this.exporter.toMarkdown(); break;
                case 'txt': this.exporter.toText(); break;
            }
            this.showToast('导出成功！', 'success');
        } catch (error) {
            this.showToast('导出失败: ' + error.message, 'error');
        }
    }
    
    newMindMap() {
        this.root = new Node({ text: '中心主题' });
        this.clearSelection();
        this.history.clear();
        this.render();
        this.centerView();
        this.saveState('新建');
    }
    
    // ========== 自动保存 ==========
    startAutoSave() {
        setInterval(() => {
            try {
                localStorage.setItem('mindmap_autosave', JSON.stringify(this.root.toJSON()));
                localStorage.setItem('mindmap_autosave_time', Date.now().toString());
            } catch (e) {}
        }, 30000);
    }
    
    loadAutoSave() {
        try {
            const saved = localStorage.getItem('mindmap_autosave');
            if (saved) {
                this.root = Node.fromJSON(JSON.parse(saved));
                this.render();
                this.centerView();
                return true;
            }
        } catch (e) {}
        return false;
    }
    // ========== 更新UI ==========
    updateOutline() {
        const container = document.getElementById('outline-tree');
        if (!container) return;
        container.innerHTML = this.buildOutlineHTML(this.root, 0);
    }
    
    buildOutlineHTML(node, depth) {
        const isSelected = this.selectedNodes.has(node.id);
        const hasChildren = node.children.length > 0;
        
        let html = `<div class="outline-item ${isSelected ? 'selected' : ''}" 
                         style="--depth: ${depth}" data-node-id="${node.id}">
            <span class="expand-icon">${hasChildren ? (node.expanded ? '▼' : '▶') : ''}</span>
            <span>${node.icon || ''} ${node.text}</span>
        </div>`;
        
        if (node.expanded && hasChildren) {
            for (const child of node.children) {
                html += this.buildOutlineHTML(child, depth + 1);
            }
        }
        return html;
    }
    
    updateMinimap() {
        const canvas = document.getElementById('minimap-canvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        canvas.width = 180;
        canvas.height = 120;
        
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(0, 0, 180, 120);
        
        const scale = 0.025;
        const offsetX = 90;
        const offsetY = 60;
        
        this.drawMinimapNode(ctx, this.root, scale, offsetX, offsetY);
    }
    
    drawMinimapNode(ctx, node, scale, offsetX, offsetY) {
        const x = node.x * scale + offsetX;
        const y = node.y * scale + offsetY;
        
        const colors = this.themes.getCurrentTheme().colors;
        ctx.fillStyle = node.style.backgroundColor || colors[0];
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
        
        if (node.expanded) {
            for (const child of node.children) {
                const cx = child.x * scale + offsetX;
                const cy = child.y * scale + offsetY;
                
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(cx, cy);
                ctx.stroke();
                
                this.drawMinimapNode(ctx, child, scale, offsetX, offsetY);
            }
        }
    }
    
    updateStylePanel(node) {
        if (!node) return;
        
        const bgColor = document.getElementById('node-bg-color');
        const textColor = document.getElementById('node-text-color');
        const fontSize = document.getElementById('node-font-size');
        const shape = document.getElementById('node-shape');
        const note = document.getElementById('node-note');
        const link = document.getElementById('node-link');
        
        if (bgColor) bgColor.value = node.style.backgroundColor || '#4ECDC4';
        if (textColor) textColor.value = node.style.textColor || '#ffffff';
        if (fontSize) {
            fontSize.value = node.style.fontSize || 14;
            document.getElementById('font-size-value').textContent = (node.style.fontSize || 14) + 'px';
        }
        if (shape) shape.value = node.style.shape || 'rounded';
        if (note) note.value = node.note || '';
        if (link) link.value = node.link || '';
        
        // 更新图标选择
        document.querySelectorAll('.icon-option').forEach(opt => {
            opt.classList.toggle('active', opt.dataset.icon === node.icon);
        });
    }
    
    // ========== 侧边栏折叠/展开逻辑（修复） ==========
    togglePanel(panel, forceOpen = false) {
        const panelEl = document.getElementById(`${panel}-panel`);
        const expandBtn = document.getElementById(`expand-${panel}-panel`);
        const containerEl = this.container || document.querySelector('.canvas-container');
        
        if (!panelEl) return;
        
        if (forceOpen) {
            // 打开面板
            panelEl.classList.remove('collapsed');
            if (containerEl) containerEl.classList.remove(`${panel}-collapsed`);
            if (expandBtn) expandBtn.classList.remove('visible');
        } else {
            // 切换折叠状态
            const isCollapsed = panelEl.classList.toggle('collapsed');
            if (containerEl) containerEl.classList.toggle(`${panel}-collapsed`, isCollapsed);
            
            if (expandBtn) {
                expandBtn.classList.toggle('visible', isCollapsed);
            }
        }
    }

    // ========== UI辅助方法 ==========
    showToast(message, type = 'info') {
        const container = document.getElementById('toast-container');
        const icons = { success: '✅', error: '❌', warning: '⚠️', info: 'ℹ️' };
        
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.innerHTML = `
            <span class="toast-icon">${icons[type]}</span>
            <span class="toast-message">${message}</span>
            <button class="toast-close">&times;</button>
        `;
        
        toast.querySelector('.toast-close').onclick = () => toast.remove();
        container.appendChild(toast);
        
        setTimeout(() => toast.remove(), 3000);
    }
    
    showLoading(text = '处理中...') {
        document.getElementById('loading-text').textContent = text;
        document.getElementById('loading-overlay').classList.add('visible');
    }
    
    hideLoading() {
        document.getElementById('loading-overlay').classList.remove('visible');
    }
    
    showModal(id) {
        document.getElementById(id)?.classList.add('visible');
    }
    
    hideModal(id) {
        document.getElementById(id)?.classList.remove('visible');
    }
    
    showContextMenu(x, y) {
        const menu = document.getElementById('context-menu');
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        menu.classList.add('visible');
    }
    
    hideContextMenu() {
        document.getElementById('context-menu')?.classList.remove('visible');
    }
    
    // ========== 事件绑定 ==========
    bindEvents() {
        this.bindPanning();
        this.bindZooming();
        this.bindKeyboard();
        this.bindNodeEvents();
        this.bindContextMenu();
        this.bindToolbar();
        this.bindSidebar();
        this.bindModals();
        this.bindDragDrop();
    }
    
    bindPanning() {
        let startX, startY;
        
        this.container.addEventListener('mousedown', (e) => {
            if (e.button === 1 || (e.button === 0 && !e.target.closest('.mind-node') && !e.target.closest('.panel-expand-btn'))) {
                this.isPanning = true;
                startX = e.clientX - this.panX;
                startY = e.clientY - this.panY;
                this.container.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (this.isPanning) {
                this.panX = e.clientX - startX;
                this.panY = e.clientY - startY;
                this.updateTransform();
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (this.isPanning) {
                this.isPanning = false;
                this.container.style.cursor = 'grab';
            }
        });
    }
    
    bindZooming() {
        this.container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.08 : 0.08;
            const newScale = Math.max(0.2, Math.min(3, this.scale + delta));
            
            const rect = this.container.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const ratio = newScale / this.scale;
            this.panX = mouseX - (mouseX - this.panX) * ratio;
            this.panY = mouseY - (mouseY - this.panY) * ratio;
            
            this.scale = newScale;
            this.updateTransform();
            this.showZoomHint();
        });
    }
    
    bindKeyboard() {
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                if (e.key === 'Escape') e.target.blur();
                return;
            }
            
            const selected = this.getFirstSelected();
            
            switch (e.key) {
                case 'Tab':
                    e.preventDefault();
                    if (selected) this.addChild(selected.id);
                    else this.addChild(this.root.id);
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (selected && !selected.isRoot()) this.addSibling(selected.id);
                    break;
                case 'Delete':
                case 'Backspace':
                    e.preventDefault();
                    this.deleteSelectedNodes();
                    break;
                case 'F2':
                    e.preventDefault();
                    if (selected) this.startEdit(selected);
                    break;
                case ' ':
                    e.preventDefault();
                    if (selected && selected.hasChildren()) {
                        selected.toggleExpand();
                        this.render();
                    }
                    break;
                case 'Escape':
                    this.clearSelection();
                    this.hideContextMenu();
                    break;
                case 'z':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        if (e.shiftKey) this.redo();
                        else this.undo();
                    }
                    break;
                case 'y':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        this.redo();
                    }
                    break;
                case 'c':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        this.copyNodes();
                    }
                    break;
                case 'v':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        this.pasteNodes();
                    }
                    break;
                case 'a':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        this.traverseNodes(n => this.selectNode(n.id, true));
                    }
                    break;
                case 'ArrowUp':
                case 'ArrowDown':
                case 'ArrowLeft':
                case 'ArrowRight':
                    e.preventDefault();
                    this.navigateNodes(e.key.replace('Arrow', '').toLowerCase());
                    break;
            }
        });
    }
    
    navigateNodes(direction) {
        const selected = this.getFirstSelected();
        if (!selected) {
            this.selectNode(this.root.id);
            return;
        }
        
        let target = null;
        const parent = selected.parentId ? this.findNode(selected.parentId) : null;
        
        switch (direction) {
            case 'up':
                if (parent) {
                    const idx = parent.children.findIndex(c => c.id === selected.id);
                    if (idx > 0) target = parent.children[idx - 1];
                }
                break;
            case 'down':
                if (parent) {
                    const idx = parent.children.findIndex(c => c.id === selected.id);
                    if (idx < parent.children.length - 1) target = parent.children[idx + 1];
                }
                break;
            case 'left':
                if (parent) target = parent;
                break;
            case 'right':
                if (selected.children.length > 0 && selected.expanded) {
                    target = selected.children[0];
                }
                break;
        }
        
        if (target) {
            this.clearSelection();
            this.selectNode(target.id);
        }
    }
    
    bindNodeEvents() {
        this.nodesContainer.addEventListener('click', (e) => {
            const nodeEl = e.target.closest('.mind-node');
            if (!nodeEl) return;
            
            const nodeId = nodeEl.dataset.nodeId;
            const node = this.findNode(nodeId);
            if (!node) return;
            
            if (e.target.classList.contains('node-expand-btn')) {
                node.toggleExpand();
                this.render();
                return;
            }
            
            if (e.ctrlKey || e.metaKey) {
                this.selectNode(nodeId, true);
            } else {
                this.clearSelection();
                this.selectNode(nodeId);
            }
            
            this.hideContextMenu();
        });
        
        this.nodesContainer.addEventListener('dblclick', (e) => {
            const nodeEl = e.target.closest('.mind-node');
            if (!nodeEl) return;
            
            const node = this.findNode(nodeEl.dataset.nodeId);
            if (node) this.startEdit(node);
        });
        
        this.nodesContainer.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            
            const nodeEl = e.target.closest('.mind-node');
            if (nodeEl) {
                const nodeId = nodeEl.dataset.nodeId;
                if (!this.selectedNodes.has(nodeId)) {
                    this.clearSelection();
                    this.selectNode(nodeId);
                }
            }
            
            this.showContextMenu(e.clientX, e.clientY);
        });
        
        // 大纲点击
        document.getElementById('outline-tree')?.addEventListener('click', (e) => {
            const item = e.target.closest('.outline-item');
            if (item) {
                const nodeId = item.dataset.nodeId;
                this.clearSelection();
                this.selectNode(nodeId);
                
                const node = this.findNode(nodeId);
                if (node) {
                    this.panX = -node.x + this.container.clientWidth / 2 - 100;
                    this.panY = -node.y + this.container.clientHeight / 2;
                    this.updateTransform();
                }
            }
        });
    }
    
    bindDragDrop() {
        let dragStartX, dragStartY, dragOffsetX, dragOffsetY;
        
        this.nodesContainer.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            const nodeEl = e.target.closest('.mind-node');
            if (!nodeEl || e.target.classList.contains('node-expand-btn')) return;
            
            const node = this.findNode(nodeEl.dataset.nodeId);
            if (!node || node.isRoot()) return;
            
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            
            const rect = nodeEl.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
            
            const startDrag = () => {
                this.isDragging = true;
                this.dragNode = node;
                this.renderer.setDragging(node, true);
                this.saveState('拖拽前');
            };
            
            const checkDrag = (moveE) => {
                if (Math.abs(moveE.clientX - dragStartX) > 5 || Math.abs(moveE.clientY - dragStartY) > 5) {
                    document.removeEventListener('mousemove', checkDrag);
                    startDrag();
                }
            };
            
            document.addEventListener('mousemove', checkDrag);
            
            document.addEventListener('mouseup', () => {
                document.removeEventListener('mousemove', checkDrag);
            }, { once: true });
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!this.isDragging || !this.dragNode) return;
            
            const newX = (e.clientX - this.panX - dragOffsetX) / this.scale;
            const newY = (e.clientY - this.panY - dragOffsetY - 56) / this.scale;
            
            this.dragNode.x = newX;
            this.dragNode.y = newY;
            
            const el = this.renderer.nodeElements.get(this.dragNode.id);
            if (el) {
                el.style.left = newX + 'px';
                el.style.top = newY + 'px';
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (this.isDragging && this.dragNode) {
                this.renderer.setDragging(this.dragNode, false);
                this.render();
                this.isDragging = false;
                this.dragNode = null;
            }
        });
    }
    
    bindContextMenu() {
        const menu = document.getElementById('context-menu');
        
        menu.addEventListener('click', (e) => {
            const item = e.target.closest('.menu-item');
            if (!item) return;
            
            const action = item.dataset.action;
            const selected = this.getFirstSelected();
            
            switch (action) {
                case 'add-child':
                    if (selected) this.addChild(selected.id);
                    break;
                case 'add-sibling':
                    if (selected && !selected.isRoot()) this.addSibling(selected.id);
                    break;
                case 'edit':
                    if (selected) this.startEdit(selected);
                    break;
                case 'copy':
                    this.copyNodes();
                    break;
                case 'paste':
                    this.pasteNodes();
                    break;
                case 'expand-all':
                    if (selected) { selected.expandAll(); this.render(); }
                    break;
                case 'collapse-all':
                    if (selected) { selected.collapseAll(); this.render(); }
                    break;
                case 'ai-expand':
                    if (selected) this.aiExpandNode(selected);
                    break;
                case 'delete':
                    this.deleteSelectedNodes();
                    break;
            }
            
            this.hideContextMenu();
        });
        
        document.addEventListener('click', (e) => {
            if (!menu.contains(e.target)) this.hideContextMenu();
        });
    }
    
    bindToolbar() {
        document.getElementById('btn-new')?.addEventListener('click', () => {
            if (confirm('确定新建？未保存的内容将丢失。')) this.newMindMap();
        });
        
        document.getElementById('btn-save')?.addEventListener('click', () => {
            this.exporter.toJSON('mindmap');
        });
        
        document.getElementById('btn-load')?.addEventListener('click', () => {
            document.getElementById('file-input').click();
        });
        
        document.getElementById('file-input')?.addEventListener('change', async (e) => {
            if (e.target.files[0]) {
                await this.loadFromFile(e.target.files[0]);
            }
            e.target.value = '';
        });
        
        document.getElementById('btn-undo')?.addEventListener('click', () => this.undo());
        document.getElementById('btn-redo')?.addEventListener('click', () => this.redo());
        
        document.getElementById('btn-add-child')?.addEventListener('click', () => {
            const selected = this.getFirstSelected() || this.root;
            this.addChild(selected.id);
        });
        
        document.getElementById('btn-add-sibling')?.addEventListener('click', () => {
            const selected = this.getFirstSelected();
            if (selected && !selected.isRoot()) this.addSibling(selected.id);
        });
        
        document.getElementById('btn-delete')?.addEventListener('click', () => {
            this.deleteSelectedNodes();
        });
        
        // 打开"API智能生成"面板
        document.getElementById('btn-ai-generate')?.addEventListener('click', () => {
            document.getElementById('ai-input').value = '';
            document.getElementById('char-count').textContent = '0';
            this.showModal('ai-generate-modal');
        });
        
        // 打开"本地分析"面板
        document.getElementById('btn-ai-analyze')?.addEventListener('click', () => {
            document.getElementById('analyze-input').value = '';
            document.getElementById('analyze-char-count').textContent = '0';
            this.showModal('analyze-modal');
        });

        document.getElementById('theme-select')?.addEventListener('change', (e) => {
            this.setTheme(e.target.value);
            this.render();
        });
        
        document.getElementById('btn-zoom-in')?.addEventListener('click', () => this.zoomIn());
        document.getElementById('btn-zoom-out')?.addEventListener('click', () => this.zoomOut());
        document.getElementById('btn-zoom-fit')?.addEventListener('click', () => this.zoomToFit());
        
        document.querySelectorAll('[data-export]').forEach(btn => {
            btn.addEventListener('click', () => this.exportAs(btn.dataset.export));
        });
        
        document.getElementById('btn-settings')?.addEventListener('click', () => {
            this.showModal('settings-modal');
            this.loadSettingsForm();
        });
        
        // 面板折叠/展开（面板内的切换按钮）
        document.querySelectorAll('.panel-toggle').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.togglePanel(btn.dataset.panel);
            });
        });

        // 侧边栏展开按钮点击事件（悬浮按钮）
        const leftExpandBtn = document.getElementById('expand-left-panel');
        const rightExpandBtn = document.getElementById('expand-right-panel');
        
        if (leftExpandBtn) {
            leftExpandBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.togglePanel('left', true);
            });
        }
        
        if (rightExpandBtn) {
            rightExpandBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.togglePanel('right', true);
            });
        }
    }
    
    bindSidebar() {
        // 背景色
        document.getElementById('node-bg-color')?.addEventListener('input', (e) => {
            this.updateSelectedNodeStyle({ backgroundColor: e.target.value });
        });
        
        // 文字颜色
        document.getElementById('node-text-color')?.addEventListener('input', (e) => {
            this.updateSelectedNodeStyle({ textColor: e.target.value });
        });
        
        // 字体大小
        document.getElementById('node-font-size')?.addEventListener('input', (e) => {
            document.getElementById('font-size-value').textContent = e.target.value + 'px';
            this.updateSelectedNodeStyle({ fontSize: parseInt(e.target.value) });
        });
        
        // 形状
        document.getElementById('node-shape')?.addEventListener('change', (e) => {
            this.updateSelectedNodeStyle({ shape: e.target.value });
        });
        
        // 图标
        document.querySelectorAll('.icon-option').forEach(opt => {
            opt.addEventListener('click', () => {
                const node = this.getFirstSelected();
                if (node) {
                    node.icon = opt.dataset.icon;
                    this.render();
                    this.saveState('修改图标');
                }
                document.querySelectorAll('.icon-option').forEach(o => o.classList.remove('active'));
                opt.classList.add('active');
            });
        });
        
        // 备注
        document.getElementById('node-note')?.addEventListener('input', (e) => {
            const node = this.getFirstSelected();
            if (node) node.note = e.target.value;
        });
        
        // 链接
        document.getElementById('node-link')?.addEventListener('input', (e) => {
            const node = this.getFirstSelected();
            if (node) node.link = e.target.value;
        });
        
        // 初始化颜色预设
        const presets = document.getElementById('bg-presets');
        if (presets) {
            const colors = ['#4ECDC4', '#3498DB', '#9B59B6', '#E74C3C', '#F39C12', '#2ECC71', '#1ABC9C', '#34495E'];
            colors.forEach(color => {
                const span = document.createElement('span');
                span.className = 'color-preset';
                span.style.backgroundColor = color;
                span.dataset.color = color;
                span.onclick = () => {
                    document.getElementById('node-bg-color').value = color;
                    this.updateSelectedNodeStyle({ backgroundColor: color });
                };
                presets.appendChild(span);
            });
        }
    }
    
    updateSelectedNodeStyle(styles) {
        const nodes = this.getSelectedNodes();
        for (const node of nodes) {
            Object.assign(node.style, styles);
        }
        if (nodes.length > 0) {
            this.render();
            this.saveState('修改样式');
        }
    }
    
    bindModals() {
        // 关闭弹窗
        document.querySelectorAll('.modal-close, .modal-overlay').forEach(el => {
            el.addEventListener('click', (e) => {
                const modal = e.target.closest('.modal');
                if (modal) this.hideModal(modal.id);
            });
        });
        
        // ========== AI生成面板（API） ==========
        // "开始生成"按钮 - API智能生成模式
        document.getElementById('btn-ai-submit')?.addEventListener('click', () => {
            const input = document.getElementById('ai-input').value.trim();
            if (!input) {
                this.showToast('请输入主题或问题', 'warning');
                return;
            }
            const template = document.getElementById('ai-template').value;
            this.hideModal('ai-generate-modal');
            // 调用API生成（mode='topic'）
            this.aiGenerate(input, 'topic', template, '');
        });
        
        // "取消"按钮 - AI生成面板
        document.getElementById('btn-ai-cancel')?.addEventListener('click', () => {
            this.hideModal('ai-generate-modal');
        });
        
        // 字数统计 - AI生成面板
        document.getElementById('ai-input')?.addEventListener('input', (e) => {
            document.getElementById('char-count').textContent = e.target.value.length;
        });

        // ========== 本地分析面板 ==========
        // "开始分析"按钮 - 本地分析
        document.getElementById('btn-analyze-submit')?.addEventListener('click', () => {
            const input = document.getElementById('analyze-input').value.trim();
            if (!input) {
                this.showToast('请输入文本或列表', 'warning');
                return;
            }
            const analysisType = document.getElementById('analyze-type').value;
            this.hideModal('analyze-modal');
            // 调用本地分析（mode='analyze'）
            this.aiGenerate(input, 'analyze', '', analysisType);
        });
        
        // "取消"按钮 - 分析面板
        document.getElementById('btn-analyze-cancel')?.addEventListener('click', () => {
            this.hideModal('analyze-modal');
        });
        
        // 字数统计 - 分析面板
        document.getElementById('analyze-input')?.addEventListener('input', (e) => {
            document.getElementById('analyze-char-count').textContent = e.target.value.length;
        });
        
        // 设置
        document.getElementById('btn-save-settings')?.addEventListener('click', () => {
            this.saveSettings();
        });
        
        document.getElementById('btn-test-api')?.addEventListener('click', () => {
            this.testAPI();
        });
        
        document.getElementById('btn-clear-config')?.addEventListener('click', () => {
            localStorage.removeItem('mindmap_api_config');
            document.getElementById('setting-api-host').value = '';
            document.getElementById('setting-api-path').value = '/v1/chat/completions';
            document.getElementById('setting-api-key').value = '';
            document.getElementById('setting-model').value = '';
            this.aiService.configure({});
            this.updateAPIStatus(false);
            this.showToast('配置已清除', 'info');
        });

        // 模型预设按钮点击
        document.querySelectorAll('.model-preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.getElementById('setting-model').value = btn.dataset.model;
            });
        });
    }
    
    loadSettingsForm() {
        const saved = localStorage.getItem('mindmap_api_config');
        if (saved) {
            try {
                const config = JSON.parse(saved);
                document.getElementById('setting-api-host').value = config.apiHost || '';
                document.getElementById('setting-api-path').value = config.apiPath || '/v1/chat/completions';
                document.getElementById('setting-api-key').value = config.apiKey || '';
                document.getElementById('setting-model').value = config.model || '';
                this.updateAPIStatus(!!config.apiHost && !!config.apiKey);
            } catch (e) {}
        } else {
            this.updateAPIStatus(false);
        }
    }
    
    saveSettings() {
        const apiHost = document.getElementById('setting-api-host').value.trim();
        const apiPath = document.getElementById('setting-api-path').value.trim() || '/v1/chat/completions';
        const apiKey = document.getElementById('setting-api-key').value.trim();
        const model = document.getElementById('setting-model').value.trim();
        
        // 如果填写了主机地址，则必须同时填写密钥和模型
        if (apiHost) {
            if (!apiKey) {
                this.showToast('❌ 填写了 API 主机地址，必须也填写 API 密钥', 'warning');
                return;
            }
            if (!model) {
                this.showToast('❌ 填写了 API 主机地址，必须也填写模型名称', 'warning');
                return;
            }
            // 验证主机地址格式
            try {
                new URL(apiHost);
            } catch (e) {
                this.showToast('❌ API 主机地址格式错误！必须是有效URL（如 https://api.openai.com）', 'error');
                return;
            }
        }
        
        const config = { apiHost, apiPath, apiKey, model };
        
        localStorage.setItem('mindmap_api_config', JSON.stringify(config));
        this.aiService.configure(config);
        this.updateAPIStatus(!!apiHost && !!apiKey);
        this.hideModal('settings-modal');
        this.showToast('✅ 设置已保存！' + (apiHost ? '点击"测试连接"验证' : '使用本地模式'), 'success');
    }
    
    async testAPI() {
        const host = document.getElementById('setting-api-host').value.trim();
        const path = document.getElementById('setting-api-path').value.trim() || '/v1/chat/completions';
        const key = document.getElementById('setting-api-key').value.trim();
        const model = document.getElementById('setting-model').value.trim();
        
        if (!host || !key) {
            this.showToast('请填写 API 主机地址和密钥', 'warning');
            return;
        }
        
        if (!model) {
            this.showToast('请填写模型名称', 'warning');
            return;
        }

        // 验证主机地址格式
        try {
            new URL(host);
        } catch (e) {
            this.showToast('❌ API 主机地址格式错误！必须是有效URL（如 https://api.openai.com）', 'error');
            return;
        }
        
        // 拼接完整 URL
        const fullUrl = host.replace(/\/$/, '') + (path.startsWith('/') ? path : '/' + path);
        
        this.updateAPIStatus(null); // 测试中
        this.showToast('⏳ 正在测试 API 连接...', 'info');
        
        try {
            console.log('🔌 测试 API:', { host, path, fullUrl, model });
            const response = await fetch(fullUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${key}`
                },
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'user', content: 'test' }],
                    max_tokens: 10,
                    temperature: 0.5
                })
            });
            
            console.log('📡 API响应状态:', response.status);
            const data = await response.json();
            console.log('📨 API响应数据:', data);
            
            if (response.ok && data.choices && data.choices[0]) {
                this.updateAPIStatus(true);
                this.showToast('✅ API 连接成功！可以开始使用', 'success');
            } else if (response.status === 401) {
                throw new Error('❌ API 密钥错误或已过期（HTTP 401）- 请检查密钥是否正确');
            } else if (response.status === 404) {
                throw new Error('❌ API 路径错误（HTTP 404）- 请检查 API 路径是否正确');
            } else if (response.status === 429) {
                throw new Error('❌ API 请求过于频繁，已被限流（HTTP 429）');
            } else if (response.status === 500) {
                throw new Error('❌ API 服务器错误（HTTP 500）- 请稍后重试');
            } else if (data.error) {
                throw new Error(`❌ API 错误: ${data.error.message || JSON.stringify(data.error)}`);
            } else {
                throw new Error(`❌ API 返回异常（HTTP ${response.status}）- ${data.type || '未知错误'}`);
            }
        } catch (e) {
            this.updateAPIStatus(false);
            console.error('🔴 API 测试失败:', e);
            this.showToast(e.message, 'error');
        }
    }
    
    updateAPIStatus(enabled) {
        const el = document.getElementById('api-status');
        if (enabled === null) {
            el.innerHTML = '<span class="status-icon">🔄</span><span class="status-text">正在测试...</span>';
        } else if (enabled) {
            el.innerHTML = '<span class="status-icon">🟢</span><span class="status-text">API已连接</span>';
        } else {
            el.innerHTML = '<span class="status-icon">⚪</span><span class="status-text">未配置API，使用本地模式</span>';
        }
    }
}

// ==================== 应用初始化 ====================
let mindMap;

document.addEventListener('DOMContentLoaded', () => {
    console.log('🧠 MindFlow Pro 启动...');
    
    mindMap = new MindMap('canvas-container');
    
    // 添加全局诊断函数
    window.testAPI = async function() {
        console.log('\n🔧 ========== API 诊断 ==========');
        const service = mindMap.aiService;
        console.log('📌 API启用:', service.apiEnabled);
        console.log('📌 API主机:', service.apiHost);
        console.log('📌 API路径:', service.apiPath);
        console.log('📌 完整URL:', service.getFullUrl());
        console.log('📌 模型:', service.model);
        console.log('📌 密钥:', service.apiKey ? '已设置 (****)' : '未设置');
        
        if (!service.apiEnabled) {
            console.warn('⚠️ API 未启用！请先在设置中配置 API');
            return;
        }
        
        try {
            console.log('🔌 尝试测试 API 连接...');
            const testPrompt = '返回JSON: {"text":"测试","children":[{"text":"测试子节点"}]}';
            const result = await service.callAPI(testPrompt);
            console.log('✅ API 连接成功！');
            console.log('📊 返回结果:', result);
        } catch (e) {
            console.error('❌ API 连接失败:', e.message);
        }
    };
    
    // 添加全局生成测试函数
    window.testAPIGenerate = async function(topic = '海南岛的哈利波特主题公园', template = 'product') {
        console.log('\n🚀 ========== API 生成测试 ==========');
        console.log('主题:', topic);
        console.log('模板:', template);
        try {
            const result = await mindMap.aiService.generateFromTopic(topic, { template });
            console.log('✅ 生成完成');
            console.log('📊 结果:', JSON.stringify(result, null, 2).substring(0, 500));
            return result;
        } catch (e) {
            console.error('❌ 生成失败:', e);
        }
    };
    
    // 添加全局测试函数
    window.testGenerate = async function() {
        console.log('\n🧪 开始本地生成测试...');
        try {
            const result = mindMap.aiService.localGenerateFromTopic('项目管理', 'general');
            console.log('📊 本地生成结果:', JSON.stringify(result, null, 2));
            console.log('✅ 一级分支数:', result.children?.length);
            
            // 检查每个一级分支的子节点
            result.children?.forEach((branch, i) => {
                console.log(`  分支${i}: "${branch.text}" - ${branch.children?.length}个子节点`);
            });
            
            return result;
        } catch (e) {
            console.error('❌ 测试失败:', e);
        }
    };
    
    window.testNodeCreation = function(data) {
        console.log('\n🧪 开始节点创建测试...');
        try {
            const node = Node.fromJSON(data);
            console.log('✅ 节点创建成功');
            console.log('📊 根节点:', node.text);
            console.log('📊 直接子节点数:', node.children.length);
            node.children.forEach((child, i) => {
                console.log(`  子节点${i}: "${child.text}" - ${child.children?.length}个孙节点`);
            });
            return node;
        } catch (e) {
            console.error('❌ 测试失败:', e);
        }
    };
    
    window.testLocalAnalyze = async function() {
        console.log('\n🧪 开始本地分析测试...');
        const testText = '项目管理是指导一个专业团队的所有活动以实现特定的项目目标的过程。项目管理包括九个知识领域：综合管理、范围管理、时间管理、成本管理、质量管理、人力资源管理、沟通管理、风险管理和采购管理。有效的项目管理对于企业的成功至关重要，它能帮助组织完成目标、优化资源、提高效率、控制风险。通过采用项目管理的方法论，企业可以确保项目按时按质按预算完成。';
        
        try {
            const result = mindMap.aiService.textAnalyzer.analyze(testText);
            console.log('📊 本地分析结果:', JSON.stringify(result, null, 2));
            console.log('✅ 一级分支数:', result.children?.length);
            
            result.children?.forEach((branch, i) => {
                console.log(`  分支${i}: "${branch.text}" - ${branch.children?.length}个子节点`);
            });
            
            return result;
        } catch (e) {
            console.error('❌ 测试失败:', e);
        }
    };
    
    
    // 尝试恢复自动保存
    const autoSaved = localStorage.getItem('mindmap_autosave');
    const autoSaveTime = localStorage.getItem('mindmap_autosave_time');
    
    if (autoSaved && autoSaveTime) {
        const time = new Date(parseInt(autoSaveTime)).toLocaleString();
        if (confirm(`发现自动保存的内容（${time}），是否恢复？`)) {
            mindMap.loadAutoSave();
        } else {
            loadSampleData();
        }
    } else {
        loadSampleData();
    }
    
    window.mindMap = mindMap;
    console.log('✅ 启动完成！');
});

function loadSampleData() {
    const root = mindMap.root;
    root.text = 'MindFlow Pro';
    root.style.backgroundColor = '#2C3E50';
    
    const features = new Node({ text: '核心功能', style: { backgroundColor: '#3498DB' } });
    features.parentId = root.id;
    root.children.push(features);
    
    ['无限层级节点', '拖拽排序', '多选操作', '撤销/重做', '折叠展开'].forEach(t => {
        const n = new Node({ text: t });
        n.parentId = features.id;
        features.children.push(n);
    });
    
    const ai = new Node({ text: 'AI智能', style: { backgroundColor: '#9B59B6' } });
    ai.parentId = root.id;
    root.children.push(ai);
    
    ['主题自动生成', '长文本分析', '节点智能扩展'].forEach(t => {
        const n = new Node({ text: t });
        n.parentId = ai.id;
        ai.children.push(n);
    });
    
    const exp = new Node({ text: '导出格式', style: { backgroundColor: '#E74C3C' } });
    exp.parentId = root.id;
    root.children.push(exp);
    
    ['PNG/JPG图片', 'JSON数据', 'Markdown'].forEach(t => {
        const n = new Node({ text: t });
        n.parentId = exp.id;
        exp.children.push(n);
    });
    
    const shortcuts = new Node({ text: '快捷键', style: { backgroundColor: '#27AE60' } });
    shortcuts.parentId = root.id;
    root.children.push(shortcuts);
    
    ['Tab - 子节点', 'Enter - 同级', 'Delete - 删除', 'Space - 展开'].forEach(t => {
        const n = new Node({ text: t });
        n.parentId = shortcuts.id;
        shortcuts.children.push(n);
    });
    
    mindMap.render();
    mindMap.centerView();
    mindMap.saveState('示例数据');
}
    </script>
</body>
</html>
